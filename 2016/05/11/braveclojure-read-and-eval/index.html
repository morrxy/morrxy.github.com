<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Clojure,Clojure For The Branve And True," />





  <link rel="alternate" href="/atom.xml" title="胡军的网络日志" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="&amp;#x672C;&amp;#x6587;&amp;#x662F;&amp;#x6211;&amp;#x5BF9;Clojure&amp;#x4E66;&amp;#x7C4D; CLOJURE FOR THE BRAVE AND TRUE&amp;#x7B2C;&amp;#x4E03;&amp;#x7AE0;Clojure Alchemy: Reading, Evaluation, and Macros &amp;#x505A;&amp;#x7684;&amp;#x7FFB;&amp;#x8BD1;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="【译】Clojure炼金术:读取，求值，宏">
<meta property="og:url" content="http://yoursite.com/2016/05/11/braveclojure-read-and-eval/index.html">
<meta property="og:site_name" content="胡军的网络日志">
<meta property="og:description" content="&amp;#x672C;&amp;#x6587;&amp;#x662F;&amp;#x6211;&amp;#x5BF9;Clojure&amp;#x4E66;&amp;#x7C4D; CLOJURE FOR THE BRAVE AND TRUE&amp;#x7B2C;&amp;#x4E03;&amp;#x7AE0;Clojure Alchemy: Reading, Evaluation, and Macros &amp;#x505A;&amp;#x7684;&amp;#x7FFB;&amp;#x8BD1;&amp;">
<meta property="og:image" content="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/non-lisp-eval.png">
<meta property="og:image" content="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/trees.png">
<meta property="og:image" content="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/lisp-eval.png">
<meta property="og:image" content="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/data-to-eval.png">
<meta property="og:image" content="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/simple-eval.png">
<meta property="og:image" content="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/whole-shebang.png">
<meta property="og:updated_time" content="2016-05-16T02:34:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【译】Clojure炼金术:读取，求值，宏">
<meta name="twitter:description" content="&amp;#x672C;&amp;#x6587;&amp;#x662F;&amp;#x6211;&amp;#x5BF9;Clojure&amp;#x4E66;&amp;#x7C4D; CLOJURE FOR THE BRAVE AND TRUE&amp;#x7B2C;&amp;#x4E03;&amp;#x7AE0;Clojure Alchemy: Reading, Evaluation, and Macros &amp;#x505A;&amp;#x7684;&amp;#x7FFB;&amp;#x8BD1;&amp;">
<meta name="twitter:image" content="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/non-lisp-eval.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 【译】Clojure炼金术:读取，求值，宏 | 胡军的网络日志 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">胡军的网络日志</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'wmG9FieA3KCB8x2CXpVc','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                【译】Clojure炼金术:读取，求值，宏
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T15:42:47+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/braveclojure-read-and-eval/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/11/braveclojure-read-and-eval/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&#x672C;&#x6587;&#x662F;&#x6211;&#x5BF9;Clojure&#x4E66;&#x7C4D; <a href="http://www.braveclojure.com/clojure-for-the-brave-and-true/" target="_blank" rel="external">CLOJURE FOR THE BRAVE AND TRUE</a>&#x7B2C;&#x4E03;&#x7AE0;<a href="http://www.braveclojure.com/read-and-eval/" target="_blank" rel="external">Clojure Alchemy: Reading, Evaluation, and Macros</a> &#x505A;&#x7684;&#x7FFB;&#x8BD1;&#x3002;&#x7FFB;&#x8BD1;&#x5F62;&#x5F0F;&#xFF0C;&#x4E2D;&#x82F1;&#x5BF9;&#x7167;&#xFF0C;&#x82F1;&#x6587;&#x5F15;&#x7528;&#x8DDF;&#x7740;&#x4E2D;&#x6587;&#x7FFB;&#x8BD1;&#x3002;&#x5982;&#x6709;&#x9519;&#x8BEF;&#xFF0C;&#x5728;&#x6240;&#x96BE;&#x514D;&#xFF0C;&#x6B22;&#x8FCE;&#x6307;&#x6B63;&#x3002;</p>
<p>&#x5982;&#x679C;&#x4F60;&#x5BF9;Clojure&#x4E0D;&#x719F;&#x6089;&#xFF0C;&#x53EF;&#x4EE5;&#x5148;&#x770B;&#x4E00;&#x4E0B;&#x7B2C;3&#x7AE0;<a href="http://www.braveclojure.com/do-things/" target="_blank" rel="external">A Clojure Crash Course</a>;&#x5982;&#x679C;&#x5BF9;&#x67D0;&#x4E2A;&#x51FD;&#x6570;&#xFF0C;&#x5B8F;&#xFF0C;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x4E0D;&#x719F;&#x6089;&#xFF0C;&#x53EF;&#x4EE5;&#x67E5;&#x770B;<a href="http://clojuredocs.org/" target="_blank" rel="external">coojuredocs</a>&#x7684;&#x53C2;&#x8003;&#xFF0C;&#x6BCF;&#x4E2A;&#x6587;&#x6863;&#x90FD;&#x6709;&#x4F8B;&#x5B50;&#xFF0C;&#x975E;&#x5E38;&#x597D;&#x3002;</p>
<p>&#x8BD1;&#x6587;&#x5F00;&#x59CB;&#x3002;</p>
<hr>
<blockquote>
<p>The philosopher&#x2019;s stone, along with the elixir of life and Viagra, is one of the most well-known specimens of alchemical lore, pursued for its ability to transmute lead into gold. Clojure, however, offers a tool that makes the philosopher&#x2019;s stone look like a mere trinket: the macro.</p>
</blockquote>
<p>Clojure&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x79CD;&#x5DE5;&#x5177;&#xFF1A;&#x5B8F;&#x3002;</p>
<blockquote>
<p>Macros allow you to transform arbitrary expressions into valid Clojure, so you can extend the language itself to fit your needs. And you don&#x2019;t even have to be a wizened old dude or lady in a robe to use them!</p>
</blockquote>
<p>&#x5B8F;&#x5141;&#x8BB8;&#x4F60;&#x628A;&#x4EFB;&#x610F;&#x8868;&#x8FBE;&#x5F0F;&#x8F6C;&#x6362;&#x6210;&#x5408;&#x6CD5;&#x7684;Clojure&#xFF0C;&#x6240;&#x4EE5;&#x4F60;&#x80FD;&#x591F;&#x6269;&#x5C55;&#x8BED;&#x8A00;&#x4EE5;&#x7B26;&#x5408;&#x4F60;&#x7684;&#x9700;&#x6C42;&#x3002;</p>
<blockquote>
<p>To get just a sip of this power, consider this trivial macro:</p>
</blockquote>
<p>&#x770B;&#x4E0B;&#x8FD9;&#x4E2A;&#x5B8F;&#x7684;&#x4F8B;&#x5B50;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> backwards</span><br><span class="line">  [form]</span><br><span class="line">  (<span class="name"><span class="builtin-name">reverse</span></span> form))</span><br><span class="line"></span><br><span class="line">(<span class="name">backwards</span> (<span class="string">&quot; backwards&quot;</span> <span class="string">&quot; am&quot;</span> <span class="string">&quot;I&quot;</span> str))</span><br><span class="line"><span class="comment">; =&gt; &quot;I am backwards&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The backwards macro allows Clojure to successfully evaluate the expression <code>(&quot; backwards&quot; &quot; am&quot; &quot;I&quot; str)</code>, even though it doesn&#x2019;t follow Clojure&#x2019;s built-in syntax rules, which require an expression&#x2019;s operand to appear first (not to mention the rule that an expression not be written in reverse order). Without backwards, the expression would fail harder than millennia of alchemists ironically spending their entire lives pursuing an impossible means of achieving immortality. With backwards, you&#x2019;ve created your own syntax! You&#x2019;ve extended Clojure so you can write code however you please! Better than turning lead into gold, I tell you!</p>
</blockquote>
<p>&#x867D;&#x7136;&#x8868;&#x8FBE;&#x5F0F;<code>(&quot; backwards&quot; &quot; am&quot; &quot;I&quot; str)</code>&#x4E0D;&#x662F;&#x5408;&#x6CD5;&#x7684;Clojure&#x8868;&#x8FBE;&#x5F0F;&#xFF0C;&#x4F46;&#x4F7F;&#x7528;<code>backwards</code>&#x5B8F;&#x4F7F;Clojure&#x80FD;&#x6210;&#x529F;&#x5BF9;&#x5B83;&#x6C42;&#x503C;&#x3002;&#x76F8;&#x5F53;&#x4E8E;&#x4F60;&#x7528;&#x8FD9;&#x4E2A;&#x5B8F;&#x521B;&#x9020;&#x4E86;&#x81EA;&#x5DF1;&#x7684;&#x8BED;&#x6CD5;&#x3002;</p>
<blockquote>
<p>This chapter gives you the conceptual foundation you need to go mad with power writing your own macros. It explains the elements of Clojure&#x2019;s evaluation model: the <code>reader</code>, the <code>evaluator</code>, and the <code>macro expander</code>. It&#x2019;s like the periodic table of Clojure elements. Think of how the periodic table reveals the properties of atoms: elements in the same column behave similarly because they have the same nuclear charge. Without the periodic table and its underlying theory, we&#x2019;d be in the same position as the alchemists of yore, mixing stuff together randomly to see what blows up. But with a deeper understanding of the elements, you can see why stuff blows up and learn how to blow stuff up on purpose.</p>
</blockquote>
<p>&#x8FD9;&#x7AE0;&#x8BB2;&#x8FF0;&#x5199;&#x5B8F;&#x9700;&#x8981;&#x7528;&#x5230;&#x7684;&#x57FA;&#x7840;&#x6982;&#x5FF5;&#x3002;&#x89E3;&#x91CA;&#x4E86;Clojure&#x6C42;&#x503C;&#x6A21;&#x578B;&#x7684;&#x4E09;&#x4E2A;&#x65B9;&#x9762;&#xFF1A;<code>reader</code>(&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;)&#xFF0C;<code>evaluator</code>(&#x6C42;&#x503C;&#x7A0B;&#x5E8F;)&#xFF0C;<code>macro expander</code>(&#x5B8F;&#x5C55;&#x5F00;&#x7A0B;&#x5E8F;)&#x3002;</p>
<blockquote>
<p>An Overview of Clojure&#x2019;s Evaluation Model</p>
</blockquote>
<h2 id="Clojure&#x6C42;&#x503C;&#x6A21;&#x578B;&#x6982;&#x8FF0;"><a href="#Clojure&#x6C42;&#x503C;&#x6A21;&#x578B;&#x6982;&#x8FF0;" class="headerlink" title="Clojure&#x6C42;&#x503C;&#x6A21;&#x578B;&#x6982;&#x8FF0;"></a>Clojure&#x6C42;&#x503C;&#x6A21;&#x578B;&#x6982;&#x8FF0;</h2><blockquote>
<p>Clojure (like all Lisps) has an evaluation model that differs from most other languages: it has a two-phase system where it reads textual source code, producing Clojure data structures. These data structures are then evaluated: Clojure traverses the data structures and performs actions like function application or var lookup based on the type of the data structure. For example, when Clojure reads the text <code>(+ 1 2)</code>, the result is a list data structure whose first element is a <code>+</code> symbol, followed by the numbers 1 and 2. This data structure is passed to Clojure&#x2019;s evaluator, which looks up the function corresponding to + and applies that function to 1 and 2.</p>
</blockquote>
<p>Clojure(&#x4E0E;&#x6240;&#x6709;&#x7684;Lisp&#x4E00;&#x6837;)&#x7684;&#x6C42;&#x503C;&#x6A21;&#x578B;&#x4E0E;&#x5176;&#x4ED6;&#x8BED;&#x8A00;&#x4E0D;&#x540C;&#xFF1A;&#x7531;&#x4E24;&#x6B65;&#x7EC4;&#x6210;&#x3002;&#x7B2C;&#x4E00;&#x6B65;&#x8BFB;&#x5165;&#x6587;&#x672C;&#x6E90;&#x7801;&#xFF0C;&#x4EA7;&#x751F;Clojure&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x7B2C;&#x4E8C;&#x6B65;&#x6C42;&#x503C;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x6C42;&#x503C;&#x65F6;&#x5019;&#x4F1A;&#x904D;&#x5386;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x5E76;&#x6839;&#x636E;&#x4E0D;&#x540C;&#x7684;&#x7C7B;&#x578B;&#x8FDB;&#x884C;&#x4E0D;&#x540C;&#x7684;&#x52A8;&#x4F5C;&#xFF0C;&#x6BD4;&#x5982;&#x53D8;&#x91CF;&#x67E5;&#x627E;&#xFF0C;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x3002;&#x6BD4;&#x5982;&#x6E90;&#x7801;<code>(+ 1 2)</code>,&#x8BFB;&#x5165;&#x540E;&#x4EA7;&#x751F;&#x4E00;&#x4E2A;list&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x662F;<code>+</code>&#x8FD9;&#x4E2A;symbol(&#x7B26;&#x53F7;)&#xFF0C;&#x540E;&#x9762;&#x8DDF;&#x7740;1&#x548C;2&#x3002;&#x4E4B;&#x540E;&#x8FD9;&#x4E2A;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4F20;&#x7ED9;Clojure&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#xFF0C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x627E;&#x5230;&#x5BF9;&#x5E94;&#x7B26;&#x53F7;<code>+</code>&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x7528;1&#x548C;2&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#xFF0C;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x3002;</p>
<blockquote>
<p>Languages that have this relationship between source code, data, and evaluation are called <code>homoiconic</code>. (Incidentally, if you say <code>homoiconic</code> in front of your bathroom mirror three times with the lights out, the ghost of John McCarthy appears and hands you a parenthesis.) Homoiconic languages empower you to reason about your code as a set of data structures that you can manipulate programmatically. To put this into context, let&#x2019;s take a jaunt through the land of compilation.</p>
</blockquote>
<p>&#x6E90;&#x7801;&#xFF0C;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x6C42;&#x503C;&#x662F;&#x8FD9;&#x6837;&#x5173;&#x7CFB;&#x7684;&#x8BED;&#x8A00;&#x88AB;&#x79F0;&#x4E3A;<code>homoiconic</code>&#x8BED;&#x8A00;(<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E5%83%8F%E6%80%A7" target="_blank" rel="external">&#x540C;&#x50CF;&#x6027;&#x8BED;&#x8A00;</a>)&#x3002;(&#x987A;&#x4FBF;&#x63D0;&#x4E00;&#x4E0B;&#xFF0C;&#x5982;&#x679C;&#x4F60;&#x5F00;&#x7740;&#x706F;&#xFF0C;&#x5728;&#x6D74;&#x5BA4;&#x955C;&#x5B50;&#x524D;&#x9762;&#x8BF4;&#x4E09;&#x58F0;<code>homoiconic</code>,<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E9%BA%A6%E5%8D%A1%E9%94%A1" target="_blank" rel="external">&#x7EA6;&#x7FF0;&#xB7;&#x9EA6;&#x5361;&#x9521;</a>&#x4F1A;&#x51FA;&#x73B0;&#xFF0C;&#x5E76;&#x4EA4;&#x7ED9;&#x4F60;&#x4E00;&#x5BF9;&#x5706;&#x62EC;&#x53F7;&#x3002;)&#x540C;&#x50CF;&#x6027;&#x8BED;&#x8A00;&#x4F7F;&#x4F60;&#x80FD;&#x628A;&#x4EE3;&#x7801;&#x770B;&#x6210;&#x662F;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x7A0B;&#x5E8F;&#x64CD;&#x7EB5;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x5373;&#x4F20;&#x8BF4;&#x4E2D;&#x7684;&#x7684;&#x4EE3;&#x7801;&#x5373;&#x6570;&#x636E;&#x8BED;&#x8A00;&#x3002;</p>
<blockquote>
<p>Programming languages require a compiler or interpreter for translating the code you write, which consists of Unicode characters, into something else: machine instructions, code in another programming language, whatever. During this process, the compiler constructs an <code>abstract syntax tree</code> (AST), which is a data structure that represents your program. You can think of the AST as the input to the evaluator, which you can think of as a function that traverses the tree to produce the machine code or whatever as its output.</p>
</blockquote>
<p>&#x7F16;&#x7A0B;&#x8BED;&#x8A00;&#x9700;&#x8981;&#x7F16;&#x8BD1;&#x5668;&#x6216;&#x89E3;&#x91CA;&#x5668;&#x628A;Unicode&#x5B57;&#x7B26;&#x7EC4;&#x6210;&#x7684;&#x6E90;&#x7801;&#x8F6C;&#x6362;&#x6210;&#x673A;&#x5668;&#x6307;&#x4EE4;&#xFF0C;&#x5176;&#x4ED6;&#x8BED;&#x8A00;&#x7684;&#x6E90;&#x7801;&#x7B49;&#x7B49;&#x3002;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x7F16;&#x8BD1;&#x5668;&#x6784;&#x5EFA;&#x4E00;&#x4E2A;<code>&#x62BD;&#x8C61;&#x8BED;&#x6CD5;&#x6811;</code>(AST)&#x4EE3;&#x8868;&#x6E90;&#x7A0B;&#x5E8F;&#x3002;&#x4F60;&#x53EF;&#x4EE5;&#x628A;AST&#x770B;&#x6210;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x7684;&#x8F93;&#x5165;&#xFF0C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x904D;&#x5386;&#x8FD9;&#x4E2A;&#x6811;&#xFF0C;&#x4EA7;&#x751F;&#x673A;&#x5668;&#x7801;&#x6216;&#x5176;&#x4ED6;&#x8F93;&#x51FA;&#x3002;</p>
<blockquote>
<p>So far this sounds a lot like what I described for Clojure. However, in most languages the AST&#x2019;s data structure is inaccessible within the programming language; the programming language space and the compiler space are forever separated, and never the twain shall meet. Figure 7-1 shows how you might visualize the compilation process for an expression in a non-Lisp programming language.</p>
</blockquote>
<p>&#x5728;&#x5927;&#x591A;&#x6570;&#x8BED;&#x8A00;&#x91CC;&#xFF0C;&#x7F16;&#x7A0B;&#x8BED;&#x8A00;&#x662F;&#x65E0;&#x6CD5;&#x8BBF;&#x95EE;AST&#x7684;&#xFF0C;&#x7F16;&#x7A0B;&#x8BED;&#x8A00;&#x4E0E;&#x7F16;&#x8BD1;&#x5668;&#x6C38;&#x8FDC;&#x662F;&#x9694;&#x79BB;&#x7684;&#x3002;&#x56FE;7-1&#x6F14;&#x793A;&#x4E86;&#x975E;Lisp&#x8BED;&#x8A00;&#x5BF9;&#x4E00;&#x4E2A;&#x8868;&#x8FBE;&#x5F0F;&#x7684;&#x7F16;&#x8BD1;&#x8FC7;&#x7A0B;&#x3002;</p>
<p>&#x56FE;7-1<img src="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/non-lisp-eval.png" alt="&#x56FE;7-1"></p>
<blockquote>
<p>But Clojure is different, because Clojure is a Lisp and Lisps are hotter than a stolen tamale. Instead of evaluating an AST that&#x2019;s represented as some inaccessible internal data structure, Lisps evaluate native data structures. Clojure still evaluates tree structures, but the trees are structured using Clojure lists and the nodes are Clojure values.</p>
</blockquote>
<p>&#x4F46;Clojure&#x4E0D;&#x540C;&#xFF0C;&#x56E0;&#x4E3A;Clojure&#x662F;Lisp&#x3002;Lisp&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x7684;&#x6C42;&#x503C;&#x5BF9;&#x8C61;&#x4E0D;&#x662F;&#x4E0D;&#x53EF;&#x8BBF;&#x95EE;&#x7684;&#x5185;&#x90E8;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x800C;&#x662F;&#x6E90;&#x751F;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;Clojure&#x4E5F;&#x662F;&#x5BF9;&#x6811;&#x7ED3;&#x6784;&#x6C42;&#x503C;&#xFF0C;&#x4F46;&#x6811;&#x662F;&#x7531;Clojure&#x6E90;&#x751F;list&#x6784;&#x6210;&#xFF0C;&#x6811;&#x8282;&#x70B9;&#x662F;&#x6E90;&#x751F;Clojure&#x503C;&#x3002;</p>
<blockquote>
<p>Lists are ideal for constructing tree structures. The first element of a list is treated as the root, and each subsequent element is treated as a branch. To create a nested tree, you can just use nested lists, as shown in Figure 7-2.</p>
</blockquote>
<p>&#x7528;list&#x6784;&#x9020;&#x6811;&#x7ED3;&#x6784;&#x5F88;&#x5408;&#x9002;&#x3002;list&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x662F;&#x6839;&#xFF0C;&#x6BCF;&#x4E2A;&#x540E;&#x7EED;&#x5143;&#x7D20;&#x90FD;&#x662F;&#x4E00;&#x4E2A;&#x5206;&#x652F;&#x3002;&#x5982;&#x9700;&#x6784;&#x5EFA;&#x5D4C;&#x5957;&#x6811;&#x7ED3;&#x6784;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x4F7F;&#x7528;&#x5D4C;&#x5957;&#x7684;list,&#x5982;&#x56FE;7-2&#x3002;</p>
<p>&#x56FE;7-2<img src="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/trees.png" alt="&#x56FE;7-2"></p>
<blockquote>
<p>First, Clojure&#x2019;s reader converts the text <code>(+ 1 (* 6 7))</code> into a nested list. (You&#x2019;ll learn more about the reader in the next section.) Then, Clojure&#x2019;s evaluator takes that data as input and produces a result. (It also compiles Java Virtual Machine ( JVM) bytecode, which you&#x2019;ll learn about in Chapter 12. For now, we&#x2019;ll just focus on the evaluation model on a conceptual level.)</p>
</blockquote>
<p>&#x9996;&#x5148;&#xFF0C;Clojure&#x7684;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x628A;&#x6587;&#x672C;<code>(+ 1 (* 6 7))</code>&#x8F6C;&#x6362;&#x6210;&#x4E00;&#x4E2A;&#x5D4C;&#x5957;list&#x3002;&#x7136;&#x540E;Clojure&#x7684;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x63A5;&#x53D7;&#x8FD9;&#x4E2A;list&#x6570;&#x636E;&#x5E76;&#x4EA7;&#x751F;&#x7ED3;&#x679C;&#x3002;</p>
<blockquote>
<p>With this in mind, Figure 7-3 shows what Clojure&#x2019;s evaluation process looks like.</p>
</blockquote>
<p>&#x56FE;7-3&#x8868;&#x793A;&#x4E86;Clojure&#x6C42;&#x503C;&#x8FC7;&#x7A0B;</p>
<p>&#x56FE;7-3<img src="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/lisp-eval.png" alt="&#x56FE;7-3"></p>
<blockquote>
<p><strong>S-Expressions</strong><br>In your Lisp adventures, you&#x2019;ll come across resources that explain that Lisps evaluate s-expressions. I avoid that term here because it&#x2019;s ambiguous: you&#x2019;ll see it used to refer to both the actual data object that gets evaluated and the source code that represents that data. Using the same term for two different components of Lisp evaluation (code and data) obscures what&#x2019;s important: your text represents native data structures, and Lisps evaluate native data structures, which is unique and awesome. For a great treatment of s-expressions, check out <a href="http://www.gigamonkeys.com/book/syntax-and-semantics.html" target="_blank" rel="external">http://www.gigamonkeys.com/book/syntax-and-semantics.html</a>.</p>
</blockquote>
<p>&#x5728;&#x5B66;&#x4E60;Lisp&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x4F60;&#x4F1A;&#x78B0;&#x4E0A;s-expressions(s&#x8868;&#x8FBE;&#x5F0F;)&#x7684;&#x89E3;&#x91CA;&#x3002;&#x6211;&#x907F;&#x514D;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;&#x672F;&#x8BED;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4F1A;&#x5F15;&#x8D77;&#x6B67;&#x4E49;&#x3002;&#x4F60;&#x4F1A;&#x53D1;&#x73B0;&#x5B83;&#x65E2;&#x53EF;&#x4EE5;&#x6307;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x63A5;&#x53D7;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x53C8;&#x53EF;&#x4EE5;&#x6307;&#x6E90;&#x7801;&#x3002;&#x7528;&#x540C;&#x4E00;&#x4E2A;&#x672F;&#x8BED;&#x4EE3;&#x8868;Lips&#x6C42;&#x503C;&#x7684;&#x4E24;&#x4E2A;&#x7EC4;&#x6210;&#x90E8;&#x5206;&#xFF0C;&#x63A9;&#x76D6;&#x4E86;&#x8981;&#x70B9;&#xFF1A;&#x6E90;&#x7801;&#x6587;&#x672C;&#x4EE3;&#x8868;&#x6E90;&#x751F;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;Lisp&#x5BF9;&#x6E90;&#x751F;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x6C42;&#x503C;&#xFF0C;&#x8FD9;&#x5F88;&#x72EC;&#x7279;&#x5F88;&#x68D2;&#x3002;&#x8FD9;&#x91CC;&#x6709;&#x4E00;&#x7BC7;&#x5F88;&#x597D;&#x7684;<a href="http://www.gigamonkeys.com/book/syntax-and-semantics.html" target="_blank" rel="external">s&#x8868;&#x8FBE;&#x5F0F;&#x6587;&#x7AE0;</a></p>
<blockquote>
<p>However, the evaluator doesn&#x2019;t actually care where its input comes from; it doesn&#x2019;t have to come from the reader. As a result, you can send your program&#x2019;s data structures directly to the Clojure evaluator with <code>eval</code>. Behold!</p>
</blockquote>
<p>&#x6CE8;&#x610F;&#xFF1A;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x4E0D;&#x5728;&#x4E4E;&#x8F93;&#x5165;&#x4ECE;&#x54EA;&#x6765;&#xFF0C;&#x8F93;&#x5165;&#x4E0D;&#x4E00;&#x5B9A;&#x6765;&#x81EA;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x3002;&#x56E0;&#x6B64;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x7528;<code>eval</code>&#x53D1;&#x9001;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7ED9;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x3002;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> addition-list (<span class="name"><span class="builtin-name">list</span></span> + <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">eval</span></span> addition-list)</span><br><span class="line"><span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>That&#x2019;s right, baby! Your program just evaluated a Clojure list. You&#x2019;ll read all about Clojure&#x2019;s evaluation rules soon, but briefly, this is what happened: when Clojure evaluated the list, it looked up the list that <code>addition-list</code> refers to; then it looked up the function corresponding to the <code>+</code> symbol; and then it called that function with <code>1</code> and <code>2</code> as arguments, returning <code>3</code>. The data structures of your running program and those of the evaluator live in the same space, and the upshot is that you can use the full power of Clojure and all the code you&#x2019;ve written to construct data structures for evaluation:</p>
</blockquote>
<p>&#x8FD9;&#x91CC;&#xFF0C;Clojure&#x6C42;&#x503C;&#x4E86;&#x4E00;&#x4E2A;list&#x3002;&#x8FC7;&#x7A0B;&#x662F;&#x8FD9;&#x6837;&#x7684;&#xFF1A;&#x5F53;Clojure&#x6C42;&#x503C;&#x8FD9;&#x4E2A;list&#x65F6;&#x5019;&#xFF0C;&#x627E;&#x5230;<code>addition-list</code>&#x5F15;&#x7528;&#x7684;list,&#x7136;&#x540E;&#x627E;&#x5230;&#x7B26;&#x53F7;<code>+</code>&#x5BF9;&#x5E94;&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x4EE5;<code>1</code>&#x548C;<code>2</code>&#x4E3A;&#x53C2;&#x6570;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#xFF0C;&#x8FD4;&#x56DE;<code>3</code>&#x3002;&#x8FD0;&#x884C;&#x4E2D;&#x7684;&#x7A0B;&#x5E8F;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x548C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x4F7F;&#x7528;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x5904;&#x4E8E;&#x540C;&#x4E00;&#x7A7A;&#x95F4;&#xFF0C;&#x56E0;&#x6B64;&#x4F60;&#x53EF;&#x4EE5;&#x8FD0;&#x7528;&#x6240;&#x6709;&#x7684;Clojure&#x529B;&#x91CF;&#x6784;&#x5EFA;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7528;&#x4E8E;&#x6C42;&#x503C;:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(eval (concat addition-list [10]))</span><br><span class="line">; =&gt; 13</span><br><span class="line"></span><br><span class="line">(eval (list &apos;def &apos;lucky-number (concat addition-list [10])))</span><br><span class="line">; =&gt; #&apos;user/lucky-number</span><br><span class="line"></span><br><span class="line">lucky-number</span><br><span class="line">; =&gt; 13</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Figure 7-4 shows the lists you sent to the evaluator in these two examples.</p>
</blockquote>
<p>&#x56FE;7-4&#x663E;&#x793A;&#x4E86;&#x8FD9;&#x4E24;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;&#x53D1;&#x9001;&#x7ED9;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x7684;list</p>
<p>&#x56FE;7-4<img src="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/data-to-eval.png" alt="&#x56FE;7-4"></p>
<blockquote>
<p>Your program can talk directly to its own evaluator, using its own functions and data to modify itself as it runs! Are you going mad with power yet? I hope so! Hold on to some of your sanity, though, because there&#x2019;s still more to learn.</p>
</blockquote>
<p>&#x7A0B;&#x5E8F;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x8DDF;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x5BF9;&#x8BDD;&#xFF0C;&#x7A0B;&#x5E8F;&#x8FD0;&#x884C;&#x65F6;&#x5019;&#x53EF;&#x4EE5;&#x7528;&#x7A0B;&#x5E8F;&#x91CC;&#x7684;&#x51FD;&#x6570;&#x548C;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4FEE;&#x6539;&#x81EA;&#x8EAB;&#xFF01;</p>
<blockquote>
<p>So Clojure is homoiconic: it represents abstract syntax trees using lists, and you write textual representations of lists when you write Clojure code. Because the code you write represents data structures that you&#x2019;re used to manipulating and the evaluator consumes those data structures, it&#x2019;s easy to reason about how to programmatically modify your program.</p>
</blockquote>
<p>Clojure&#x662F;&#x540C;&#x50CF;&#x6027;&#x8BED;&#x8A00;&#xFF1A;&#x7528;list&#x8868;&#x793A;&#x62BD;&#x8C61;&#x8BED;&#x6CD5;&#x6811;&#xFF0C;&#x5E76;&#x4E14;&#x6E90;&#x7801;&#x4E5F;&#x7528;list&#x8868;&#x793A;&#x3002;&#x56E0;&#x4E3A;&#x4EE3;&#x7801;&#x8868;&#x793A;&#x7684;&#x5C31;&#x662F;&#x8981;&#x64CD;&#x4F5C;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x548C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x63A5;&#x53D7;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x4FEE;&#x6539;&#x7A0B;&#x5E8F;&#x5C31;&#x5BB9;&#x6613;&#x4E86;&#x3002;</p>
<blockquote>
<p>Macros are what allow you to perform those manipulations easily. The rest of this chapter covers Clojure&#x2019;s reader and evaluation rules in detail to give you a precise understanding of how macros work.</p>
</blockquote>
<p>&#x7528;&#x5B8F;&#x53EF;&#x4EE5;&#x8F7B;&#x677E;&#x5B8C;&#x6210;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x64CD;&#x4F5C;&#x3002;&#x4E0B;&#x9762;&#x8BB2;&#x8FF0;Clojure&#x7684;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x548C;&#x6C42;&#x503C;&#x89C4;&#x5219;&#xFF0C;&#x4F7F;&#x4F60;&#x80FD;&#x51C6;&#x786E;&#x7406;&#x89E3;&#x5B8F;&#x662F;&#x5982;&#x4F55;&#x5DE5;&#x4F5C;&#x7684;&#x3002;</p>
<blockquote>
<p>The Reader</p>
</blockquote>
<h2 id="&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;"><a href="#&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;" class="headerlink" title="&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;"></a>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;</h2><blockquote>
<p>The reader converts the textual source code you save in a file or enter in the REPL into Clojure data structures. It&#x2019;s like a translator between the human world of Unicode characters and Clojure&#x2019;s world of lists, vectors, maps, symbols, and other data structures. In this section, you&#x2019;ll interact directly with the reader and learn how a handy feature, the reader macro, lets you write code more succinctly.</p>
</blockquote>
<p>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x628A;&#x5B58;&#x5728;&#x6587;&#x4EF6;&#x91CC;&#x7684;&#x6216;REPL&#x8F93;&#x5165;&#x7684;&#x6E90;&#x7801;&#x8F6C;&#x6362;&#x6210;Clojure&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x5C31;&#x50CF;&#x4E00;&#x4E2A;&#x7FFB;&#x8BD1;&#xFF0C;&#x628A;&#x4EBA;&#x7C7B;&#x4E16;&#x754C;&#x7684;Unicode&#x5B57;&#x7B26;&#x7FFB;&#x8BD1;&#x6210;Clojure&#x4E16;&#x754C;&#x7684;list, vector, map, symbol&#x548C;&#x5176;&#x4ED6;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#x6211;&#x4EEC;&#x5C06;&#x8981;&#x76F4;&#x63A5;&#x4E0E;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x4EA4;&#x4E92;&#xFF0C;&#x5E76;&#x5B66;&#x4E60;&#x4E00;&#x4E2A;&#x65B9;&#x4FBF;&#x7684;&#x529F;&#x80FD;&#xFF0C;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;&#xFF0C;&#x4F7F;&#x4EE3;&#x7801;&#x66F4;&#x7B80;&#x6D01;&#x3002;</p>
<blockquote>
<p>Reading</p>
</blockquote>
<h3 id="&#x8BFB;&#x5165;"><a href="#&#x8BFB;&#x5165;" class="headerlink" title="&#x8BFB;&#x5165;"></a>&#x8BFB;&#x5165;</h3><blockquote>
<p>To understand reading, let&#x2019;s first take a close look at how Clojure handles the text you type in the REPL. First, the REPL prompts you for text:</p>
</blockquote>
<p>&#x4E3A;&#x4E86;&#x7406;&#x89E3;&#x8BFB;&#x5165;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x4ED4;&#x7EC6;&#x770B;&#x770B;Clojure&#x5982;&#x4F55;&#x5904;&#x7406;REPL&#x91CC;&#x8F93;&#x5165;&#x7684;&#x6587;&#x5B57;&#x3002;&#x9996;&#x5148;&#xFF0C;REPL&#x63D0;&#x793A;&#x4F60;&#x8F93;&#x5165;&#x6587;&#x5B57;&#xFF1A;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Then you enter a bit of text. Maybe something like this:</p>
</blockquote>
<p>&#x7136;&#x540E;&#x4F60;&#x8F93;&#x5165;&#x4E00;&#x4E9B;&#x6587;&#x5B57;&#x3002;&#x4E5F;&#x8BB8;&#x662F;&#x8FD9;&#x6837;&#xFF1A;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (str &quot;To understand what recursion is,&quot; &quot; you must first understand recursion.&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>That text is really just a sequence of Unicode characters, but it&#x2019;s meant to represent a combination of Clojure data structures. This textual representation of data structures is called a <code>reader form</code>. In this example, the form represents a list data structure that contains three more forms: the <code>str</code> symbol and two strings.</p>
</blockquote>
<p>&#x8FD9;&#x4E9B;&#x6587;&#x5B57;&#x53EA;&#x662F;&#x4E00;&#x7CFB;&#x5217;Unicode&#x5B57;&#x7B26;&#xFF0C;&#x4F46;&#x4EE3;&#x8868;&#x7684;&#x662F;Clojure&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7EC4;&#x5408;&#x3002;&#x8FD9;&#x4E2A;&#x8868;&#x793A;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x6587;&#x672C;&#x5F62;&#x5F0F;&#x53EB;&#x505A;<code>reader form</code>(&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5F62;&#x5F0F;)&#x3002;&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;&#xFF0C;&#x8FD9;&#x4E2A;&#x5F62;&#x5F0F;&#x8868;&#x793A;&#x7684;&#x662F;&#x4E00;&#x4E2A;list&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x8FD9;&#x4E2A;list&#x53C8;&#x5305;&#x542B;&#x4E86;3&#x4E2A;&#x5F62;&#x5F0F;&#xFF1A;<code>str</code>&#x7B26;&#x53F7;&#x548C;&#x4E24;&#x4E2A;&#x5B57;&#x7B26;&#x4E32;&#x3002;</p>
<blockquote>
<p>Once you type those characters into the prompt and press enter, that text goes to the reader (remember REPL stands for read-eval-print-loop). Clojure reads the stream of characters and internally produces the corresponding data structures. It then evaluates the data structures and prints the textual representation of the result:</p>
</blockquote>
<p>&#x8F93;&#x5165;&#x5B8C;&#x6210;&#x5E76;&#x56DE;&#x8F66;&#x4E4B;&#x540E;&#xFF0C;&#x8FD9;&#x4E9B;&#x6587;&#x672C;&#x88AB;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x63A5;&#x53D7;(REPL&#x4EE3;&#x8868;&#x4E86;&#x8BFB;&#x5165;-&#x6C42;&#x503C;-&#x6253;&#x5370;-&#x5FAA;&#x73AF;)&#x3002;Clojure&#x5185;&#x90E8;&#x7528;&#x8FD9;&#x4E9B;&#x6587;&#x672C;&#x4EA7;&#x751F;&#x5BF9;&#x5E94;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x7136;&#x540E;&#x6C42;&#x503C;&#xFF0C;&#x6253;&#x5370;&#x7ED3;&#x679C;&#x7684;&#x6587;&#x672C;&#x8868;&#x793A;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;To understand what recursion is, you must first understand recursion.&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Reading and evaluation are discrete processes that you can perform independently. One way to interact with the reader directly is by using the <code>read-string</code> function. <code>read-string</code> takes a string as an argument and processes it using Clojure&#x2019;s reader, returning a data structure:</p>
</blockquote>
<p>&#x8BFB;&#x5165;&#x548C;&#x6C42;&#x503C;&#x662F;&#x80FD;&#x72EC;&#x7ACB;&#x6267;&#x884C;&#x7684;&#x5206;&#x79BB;&#x6B65;&#x9AA4;&#x3002;&#x4F7F;&#x7528;<code>read-string</code>&#x51FD;&#x6570;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x4E0E;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x4EA4;&#x4E92;&#x3002;<code>read-string</code>&#x63A5;&#x53D7;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#x4E32;&#x53C2;&#x6570;&#xFF0C;&#x7528;Clojure&#x7684;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5904;&#x7406;&#x5B83;&#xFF0C;&#x7136;&#x540E;&#x8FD4;&#x56DE;&#x6570;&#x636E;&#x7ED3;&#x6784;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-string</span> <span class="string">&quot;(+ 1 2)&quot;</span>)</span><br><span class="line"><span class="comment">; =&gt; (+ 1 2)</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">list?</span></span> (<span class="name">read-string</span> <span class="string">&quot;(+ 1 2)&quot;</span>))</span><br><span class="line"><span class="comment">; =&gt; true</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">conj</span></span> (<span class="name">read-string</span> <span class="string">&quot;(+ 1 2)&quot;</span>) <span class="symbol">:zagglewag</span>)</span><br><span class="line"><span class="comment">; =&gt; (:zagglewag + 1 2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In the first example, <code>read-string</code> reads the string representation of a list containing a plus symbol and the numbers 1 and 2. The return value is an actual list, as proven by the second example. The last example uses <code>conj</code> to prepend a keyword to the list. The takeaway is that reading and evaluating are independent of each other. You can read text without evaluating it, and you can pass the result to other functions. You can also evaluate the result, if you want:</p>
</blockquote>
<p>&#x7B2C;&#x4E00;&#x4E2A;&#x4F8B;&#x5B50;&#xFF0C;<code>read-string</code>&#x8BFB;&#x5165;&#x4E86;&#x4E00;&#x4E2A;&#x5305;&#x542B;&#x52A0;&#x53F7;&#x7B26;&#x53F7;&#x548C;&#x6570;&#x5B57;1&#xFF0C;2&#x7684;list&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x8FD4;&#x56DE;&#x5B9E;&#x9645;list&#xFF0C;&#x4ECE;&#x7B2C;&#x4E8C;&#x4E2A;&#x4F8B;&#x5B50;&#x53EF;&#x4EE5;&#x8BC1;&#x5B9E;&#x3002;&#x7B2C;&#x4E09;&#x4E2A;&#x4F8B;&#x5B50;&#x7528;<code>conj</code>&#x628A;&#x4E00;&#x4E2A;keyword&#x9644;&#x52A0;&#x5230;&#x8FD9;&#x4E2A;list&#x4E0A;&#x3002;&#x8FD9;&#x91CC;&#x7684;&#x8981;&#x70B9;&#x662F;&#x8BFB;&#x5165;&#x548C;&#x6C42;&#x503C;&#x4E92;&#x76F8;&#x72EC;&#x7ACB;&#x3002;&#x4F60;&#x53EF;&#x4EE5;&#x8BFB;&#x5165;&#x6587;&#x672C;&#x4F46;&#x4E0D;&#x6C42;&#x503C;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x628A;&#x8BFB;&#x5165;&#x7ED3;&#x679C;&#x4F20;&#x7ED9;&#x5176;&#x4ED6;&#x51FD;&#x6570;&#x3002;&#x5982;&#x679C;&#x613F;&#x610F;&#xFF0C;&#x4F60;&#x4E5F;&#x53EF;&#x4EE5;&#x6C42;&#x503C;&#x7ED3;&#x679C;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">eval</span></span> (<span class="name">read-string</span> <span class="string">&quot;(+ 1 2)&quot;</span>))</span><br><span class="line"><span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In all the examples so far, there&#x2019;s been a one-to-one relationship between the reader form and the corresponding data structures. Here are more examples of simple reader forms that directly map to the data structures they represent:</p>
</blockquote>
<p>&#x5230;&#x73B0;&#x5728;&#x7684;&#x6240;&#x6709;&#x4F8B;&#x5B50;&#xFF0C;&#x90FD;&#x662F;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5F62;&#x5F0F;&#x4E0E;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4E00;&#x4E00;&#x5BF9;&#x5E94;&#x3002;&#x66F4;&#x591A;&#x7684;&#x4F8B;&#x5B50;&#xFF1A;</p>
<blockquote>
<p>() A list reader form<br>str A symbol reader form<br>[1 2] A vector reader form containing two number reader forms<br>{:sound &#x201C;hoot&#x201D;} A map reader form with a keyword reader form and string reader form</p>
</blockquote>
<ul>
<li>() list&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5F62;&#x5F0F;</li>
<li>str symbol&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5F62;&#x5F0F;</li>
<li>[1 2] vector&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5F62;&#x5F0F;&#xFF0C;&#x5305;&#x542B;&#x4E86;&#x4E24;&#x4E2A;&#x6570;&#x5B57;&#x8BFB;&#x5165;&#x5F62;&#x5F0F;</li>
<li>{:sound &#x201C;hoot&#x201D;} map&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5F62;&#x5F0F;&#xFF0C;&#x5305;&#x542B;&#x4E24;&#x4E2A;&#x8BFB;&#x5165;&#x5F62;&#x5F0F;&#xFF0C;&#x4E00;&#x4E2A;keyword&#x548C;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#x4E32;</li>
</ul>
<blockquote>
<p>However, the reader can employ more complex behavior when converting text to data structures. For example, remember anonymous functions?</p>
</blockquote>
<p>&#x4F46;&#x662F;&#xFF0C;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x628A;&#x6587;&#x672C;&#x8F6C;&#x6362;&#x6210;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x65F6;&#x5019;&#xFF0C;&#x53EF;&#x4EE5;&#x91C7;&#x7528;&#x66F4;&#x590D;&#x6742;&#x7684;&#x884C;&#x4E3A;&#x3002;&#x8FD8;&#x8BB0;&#x5F97;&#x533F;&#x540D;&#x51FD;&#x6570;&#x5417;&#xFF1F;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">#</span>(<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> %) <span class="number">3</span>)</span><br><span class="line"><span class="comment">; =&gt; 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Well, try this out:</p>
</blockquote>
<p>&#x8BD5;&#x8BD5;&#x8FD9;&#x4E2A;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-string</span> <span class="string">&quot;#(+ 1 %)&quot;</span>)</span><br><span class="line"><span class="comment">; =&gt; (fn* [p1__423#] (+ 1 p1__423#))</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Whoa! This is not the one-to-one mapping that we&#x2019;re used to. Reading <code>#(+ 1 %)</code> somehow resulted in a list consisting of the <code>fn*</code> symbol, a vector containing a symbol, and a list containing three elements. What just happened?</p>
</blockquote>
<p>&#x64E6;&#xFF01;&#x8FD9;&#x4E0D;&#x662F;&#x4E00;&#x4E00;&#x5BF9;&#x5E94;&#x3002;&#x8BFB;&#x5165;<code>#(+ 1 %)</code>&#x751F;&#x6210;&#x4E86;&#x4E00;&#x4E2A;list&#xFF0C;&#x5305;&#x542B;<code>fn*</code>&#x7B26;&#x53F7;&#xFF0C;&#x4E00;&#x4E2A;vector(&#x542B;&#x6709;&#x4E00;&#x4E2A;&#x7B26;&#x53F7;)&#xFF0C;&#x4E00;&#x4E2A;list(&#x542B;&#x6709;3&#x4E2A;&#x6210;&#x5458;)&#x3002;&#x53D1;&#x751F;&#x4E86;&#x4EC0;&#x4E48;&#xFF1F;</p>
<blockquote>
<p>Reader Macros</p>
</blockquote>
<h3 id="&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;"><a href="#&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;" class="headerlink" title="&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;"></a>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;</h3><blockquote>
<p>I&#x2019;ll answer my own question: the reader used a <em>reader macro</em> to transform <code>#(+ 1 %)</code>. Reader macros are sets of rules for transforming text into data structures. They often allow you to represent data structures in more compact ways because they take an abbreviated reader form and expand it into a full form. They&#x2019;re designated by <em>macro characters</em>, like <code>&apos;</code> (the single quote), <code>#</code>, and <code>@</code>. They&#x2019;re also completely different from the macros we&#x2019;ll get to later. So as not to get the two confused, I&#x2019;ll always refer to reader macros using the full term reader macros.</p>
</blockquote>
<p>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x7528;&#x4E00;&#x4E2A;<em>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;</em>&#x8F6C;&#x6362;&#x4E86;<code>#(+ 1 %)</code>&#x3002;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;&#x662F;&#x4E00;&#x7EC4;&#x89C4;&#x5219;&#xFF0C;&#x7528;&#x4E8E;&#x628A;&#x6587;&#x672C;&#x8F6C;&#x6362;&#x6210;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x7531;&#x4E8E;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;&#x91C7;&#x7528;&#x4E86;&#x7F29;&#x5199;&#x7684;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5F62;&#x5F0F;&#xFF0C;&#x5E76;&#x88AB;&#x5C55;&#x5F00;&#x6210;&#x5B8C;&#x6574;&#x5F62;&#x5F0F;&#xFF0C;&#x6240;&#x4EE5;&#x53EF;&#x4EE5;&#x66F4;&#x7B80;&#x6D01;&#x5730;&#x8868;&#x793A;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x4ED6;&#x4EEC;&#x7531;<em>&#x5B8F;&#x5B57;&#x7B26;</em>&#x6807;&#x8BC6;&#xFF0C;&#x6BD4;&#x5982;<code>&#x2018;</code>(&#x5355;&#x5F15;&#x53F7;)&#xFF0C;<code>#</code>,<code>@</code>&#x3002;&#x4ED6;&#x4EEC;&#x4E0E;&#x540E;&#x9762;&#x8BB2;&#x7684;&#x5B8F;&#x5B8C;&#x5168;&#x662F;&#x4E24;&#x7801;&#x4E8B;&#x3002;&#x4E0D;&#x8981;&#x6DF7;&#x4E3A;&#x4E00;&#x8C08;&#x3002;&#x5F15;&#x7528;&#x4ED6;&#x4EEC;&#x65F6;&#x5019;&#xFF0C;&#x6211;&#x4F1A;&#x603B;&#x662F;&#x7528;&#x5B8C;&#x6574;&#x7684;<em>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;</em>&#x3002;</p>
<blockquote>
<p>For example, you can see how the quote reader macro expands the single quote character here:</p>
</blockquote>
<p>&#x4F8B;&#x5982;&#xFF0C;&#x770B;&#x770B;&#x5F15;&#x7528;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;&#x662F;&#x5982;&#x4F55;&#x6269;&#x5C55;&#x5355;&#x5F15;&#x53F7;&#x5B57;&#x7B26;&#x7684;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-string</span> <span class="string">&quot;&apos;(a b c)&quot;</span>)</span><br><span class="line"><span class="comment">; =&gt; (quote (a b c))</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>When the reader encounters the single quote, it expands it to a list whose first member is the symbol <code>quote</code> and whose second member is the data structure that followed the single quote. The <code>deref</code> reader macro works similarly for the <code>@</code> character:</p>
</blockquote>
<p>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x9047;&#x5230;&#x5355;&#x5F15;&#x53F7;&#x65F6;&#xFF0C;&#x4F1A;&#x628A;&#x5B83;&#x5C55;&#x5F00;&#x6210;&#x4E00;&#x4E2A;list&#xFF0C;&#x5176;&#x7B2C;&#x4E00;&#x4E2A;&#x6210;&#x5458;&#x662F;&#x7B26;&#x53F7;<code>quote</code>,&#x7B2C;&#x4E8C;&#x4E2A;&#x6210;&#x5458;&#x662F;&#x5355;&#x5F15;&#x53F7;&#x540E;&#x9762;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x7C7B;&#x4F3C;&#x5730;&#xFF0C;&#x5BF9;&#x4E8E;<code>@</code>&#x5B57;&#x7B26;&#xFF0C;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x7528;<code>defef</code>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;&#x5C55;&#x5F00;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-string</span> <span class="string">&quot;@var&quot;</span>)</span><br><span class="line"><span class="comment">; =&gt; (clojure.core/deref var)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Reader macros can also do crazy stuff like cause text to be ignored. The semicolon designates the single-line comment reader macro:</p>
</blockquote>
<p>&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;&#x8FD8;&#x80FD;&#x5FFD;&#x7565;&#x6587;&#x672C;&#x3002;&#x5206;&#x53F7;&#x662F;&#x5355;&#x884C;&#x6CE8;&#x91CA;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-string</span> <span class="string">&quot;; ignore!\n(+ 1 2)&quot;</span>)</span><br><span class="line"><span class="comment">; =&gt; (+ 1 2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>And that&#x2019;s the reader! Your humble companion, toiling away at transforming text into data structures. Now let&#x2019;s look at how Clojure evaluates those data structures.</p>
</blockquote>
<p>&#x8FD9;&#x5C31;&#x662F;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#xFF0C;&#x628A;&#x6587;&#x672C;&#x8F6C;&#x6362;&#x6210;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x770B;&#x770B;Clojure&#x662F;&#x5982;&#x4F55;&#x6C42;&#x503C;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x3002;</p>
<blockquote>
<p>The Evaluator</p>
</blockquote>
<h2 id="&#x6C42;&#x503C;&#x7A0B;&#x5E8F;"><a href="#&#x6C42;&#x503C;&#x7A0B;&#x5E8F;" class="headerlink" title="&#x6C42;&#x503C;&#x7A0B;&#x5E8F;"></a>&#x6C42;&#x503C;&#x7A0B;&#x5E8F;</h2><blockquote>
<p>You can think of Clojure&#x2019;s evaluator as a function that takes a data structure as an argument, processes the data structure using rules corresponding to the data structure&#x2019;s type, and returns a result. To evaluate a symbol, Clojure looks up what the symbol refers to. To evaluate a list, Clojure looks at the first element of the list and calls a function, macro, or special form. Any other values (including strings, numbers, and keywords) simply evaluate to themselves.</p>
</blockquote>
<p>&#x4F60;&#x53EF;&#x4EE5;&#x628A;Clojure&#x7684;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x770B;&#x6210;&#x4E00;&#x4E2A;&#x63A5;&#x53D7;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x7528;&#x4E0E;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7C7B;&#x578B;&#x5BF9;&#x5E94;&#x7684;&#x89C4;&#x5219;&#x5904;&#x7406;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x7ED3;&#x679C;&#x3002;&#x6C42;&#x503C;&#x7B26;&#x53F7;&#x65F6;&#xFF0C;Clojure&#x67E5;&#x627E;&#x7B26;&#x53F7;&#x7684;&#x5F15;&#x7528;&#x3002;&#x6C42;&#x503C;list&#x65F6;&#x5019;&#xFF0C;Clojure&#x67E5;&#x770B;list&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x6210;&#x5458;&#xFF0C;&#x5E76;&#x8C03;&#x7528;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#x6216;&#x5B8F;&#x6216;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x3002;&#x4EFB;&#x4F55;&#x5176;&#x4ED6;&#x503C;&#xFF0C;&#x5305;&#x62EC;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x6570;&#x5B57;&#xFF0C;keyword&#xFF0C;&#x6C42;&#x503C;&#x7ED3;&#x679C;&#x90FD;&#x662F;&#x4ED6;&#x4EEC;&#x81EA;&#x8EAB;&#x3002;</p>
<blockquote>
<p>For example, let&#x2019;s say you&#x2019;ve typed <code>(+ 1 2)</code> in the REPL. Figure 7-5 shows a diagram of the data structure that gets sent to the evaluator.</p>
</blockquote>
<p>&#x6BD4;&#x5982;&#xFF0C;&#x4F60;&#x5728;REPL&#x8F93;&#x5165;&#x4E86;<code>(+ 1 2)</code>&#x3002;&#x56FE;7-5&#x793A;&#x610F;&#x4E86;&#x53D1;&#x9001;&#x7ED9;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;</p>
<p>&#x56FE;7-5<img src="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/simple-eval.png" alt="7-5"></p>
<blockquote>
<p>Because it&#x2019;s a list, the evaluator starts by evaluating the first element in the list. The first element is the plus symbol, and the evaluator resolves that by returning the corresponding function. Because the first element in the list is a function, the evaluator evaluates each of the operands. The operands 1 and 2 evaluate to themselves because they&#x2019;re not lists or symbols. Then the evaluator calls the addition function with 1 and 2 as the operands, and returns the result.</p>
</blockquote>
<p>&#x56E0;&#x4E3A;&#x8FD9;&#x662F;&#x4E2A;list&#xFF0C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x5148;&#x6C42;&#x503C;list&#x91CC;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x3002;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x662F;&#x52A0;&#x7B26;&#x53F7;&#xFF0C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x89E3;&#x6790;&#x5B83;&#x5E76;&#x8FD4;&#x56DE;&#x5BF9;&#x5E94;&#x7684;&#x51FD;&#x6570;&#x3002;&#x7531;&#x4E8E;list&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x662F;&#x51FD;&#x6570;&#xFF0C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x7EE7;&#x7EED;&#x6C42;&#x503C;&#x6BCF;&#x4E2A;&#x64CD;&#x4F5C;&#x6570;&#x3002;&#x56E0;&#x4E3A;1&#x548C;2&#x4E0D;&#x662F;&#x7B26;&#x53F7;&#xFF0C;&#x4E5F;&#x4E0D;&#x662F;list&#xFF0C;&#x6240;&#x4EE5;&#x90FD;&#x6C42;&#x503C;&#x4E3A;&#x81EA;&#x8EAB;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x7528;1&#x548C;2&#x4F5C;&#x4E3A;&#x64CD;&#x4F5C;&#x6570;&#x8C03;&#x7528;&#x51FD;&#x6570;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x7ED3;&#x679C;&#x3002;</p>
<blockquote>
<p>The rest of this section explains the evaluator&#x2019;s rules for each kind of data structure more fully. To show how the evaluator works, we&#x2019;ll just run each example in the REPL. Keep in mind that the REPL first reads your text to get a data structure, then sends that data structure to the evaluator, and then prints the result as text.</p>
</blockquote>
<p>&#x8FD9;&#x8282;&#x7684;&#x5269;&#x4F59;&#x90E8;&#x5206;&#x5168;&#x9762;&#x89E3;&#x91CA;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x5BF9;&#x6BCF;&#x79CD;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x6C42;&#x503C;&#x89C4;&#x5219;&#x3002;</p>
<blockquote>
<p><strong>Data</strong><br>I write about how Clojure evaluates data structures in this chapter, but that&#x2019;s imprecise. Technically, data structure refers to some kind of collection, like a linked list or b-tree, or whatever, but I also use the term to refer to scalar (singular, noncollection) values like symbols and numbers. I considered using the term data objects but didn&#x2019;t want to imply object-oriented programming, or using just data but didn&#x2019;t want to confuse that with data as a concept. So, data structure it is, and if you find this offensive, I will give you a thousand apologies, thoughtfully organized in a Van Emde Boas tree.</p>
</blockquote>
<p><strong>&#x6570;&#x636E;</strong><br>&#x8FD9;&#x7AE0;&#x91CC;&#x6211;&#x7ECF;&#x5E38;&#x63D0;&#x5230;Clojure&#x6C42;&#x503C;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x4F46;&#x8FD9;&#x4E0D;&#x592A;&#x7CBE;&#x786E;&#x3002;&#x6280;&#x672F;&#x4E0A;&#x8BB2;&#xFF0C;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x662F;&#x6307;&#x67D0;&#x79CD;&#x96C6;&#x5408;&#xFF0C;&#x4F46;&#x6211;&#x4E5F;&#x7528;&#x8FD9;&#x4E2A;&#x8BCD;&#x4EE3;&#x8868;&#x7EAF;&#x91CF;(&#x5355;&#x4E2A;&#x7684;&#xFF0C;&#x975E;&#x96C6;&#x5408;)&#x503C;&#xFF0C;&#x6BD4;&#x5982;&#x7B26;&#x53F7;&#xFF0C;&#x6570;&#x5B57;&#x3002;&#x56E0;&#x4E3A;&#x6211;&#x89C9;&#x5F97;&#x7528;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x6BD4;&#x7528;&#x6570;&#x636E;&#x5BF9;&#x8C61;&#x6216;&#x6570;&#x636E;&#x66F4;&#x5408;&#x9002;&#x3002;&#x5982;&#x6709;&#x4E0D;&#x59A5;&#xFF0C;&#x6DF1;&#x8868;&#x6B49;&#x610F;&#x3002;</p>
<blockquote>
<p>These Things Evaluate to Themselves</p>
</blockquote>
<h3 id="&#x8FD9;&#x4E9B;&#x4E1C;&#x897F;&#x6C42;&#x503C;&#x7ED3;&#x679C;&#x662F;&#x4ED6;&#x4EEC;&#x81EA;&#x8EAB;"><a href="#&#x8FD9;&#x4E9B;&#x4E1C;&#x897F;&#x6C42;&#x503C;&#x7ED3;&#x679C;&#x662F;&#x4ED6;&#x4EEC;&#x81EA;&#x8EAB;" class="headerlink" title="&#x8FD9;&#x4E9B;&#x4E1C;&#x897F;&#x6C42;&#x503C;&#x7ED3;&#x679C;&#x662F;&#x4ED6;&#x4EEC;&#x81EA;&#x8EAB;"></a>&#x8FD9;&#x4E9B;&#x4E1C;&#x897F;&#x6C42;&#x503C;&#x7ED3;&#x679C;&#x662F;&#x4ED6;&#x4EEC;&#x81EA;&#x8EAB;</h3><blockquote>
<p>Whenever Clojure evaluates data structures that aren&#x2019;t a list or symbol, the result is the data structure itself:</p>
</blockquote>
<p>&#x65E0;&#x8BBA;&#x4F55;&#x65F6;&#xFF0C;Clojure&#x6C42;&#x503C;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x5982;&#x679C;&#x4E0D;&#x662F;list&#x6216;&#x7B26;&#x53F7;&#xFF0C;&#x7ED3;&#x679C;&#x90FD;&#x662F;&#x4ED6;&#x4EEC;&#x81EA;&#x8EAB;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="comment">; =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="comment">; =&gt; false</span></span><br><span class="line"></span><br><span class="line">{}</span><br><span class="line"><span class="comment">; =&gt; {}</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">:huzzah</span></span><br><span class="line"><span class="comment">; =&gt; :huzzah</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Empty lists evaluate to themselves, too:</p>
</blockquote>
<p>&#x7A7A;list&#x4E5F;&#x6C42;&#x503C;&#x4E3A;&#x81EA;&#x8EAB;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">()</span><br><span class="line"><span class="comment">; =&gt; ()</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>symbols</p>
</blockquote>
<h3 id="&#x7B26;&#x53F7;"><a href="#&#x7B26;&#x53F7;" class="headerlink" title="&#x7B26;&#x53F7;"></a>&#x7B26;&#x53F7;</h3><blockquote>
<p>One of your fundamental tasks as a programmer is creating abstractions by associating names with values. You learned how to do this in Chapter 3 by using <code>def</code>, <code>let</code>, and function definitions. Clojure uses <em>symbols</em> to name functions, macros, data, and anything else you can use, and evaluates them by <em>resolving</em> them. To resolve a symbol, Clojure traverses any bindings you&#x2019;ve created and then looks up the symbol&#x2019;s entry in a namespace mapping, which you learned about in Chapter 6. Ultimately, a symbol resolves to either a <em>value</em> or a <em>special form</em>&#x2014;a built-in Clojure operator that provides fundamental behavior.</p>
</blockquote>
<p>&#x7A0B;&#x5E8F;&#x5458;&#x7684;&#x4E00;&#x4E2A;&#x91CD;&#x8981;&#x4EFB;&#x52A1;&#x5C31;&#x662F;&#x5EFA;&#x7ACB;&#x540D;&#x5B57;&#x548C;&#x503C;&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x8054;&#x3002;&#x7B2C;3&#x7AE0;&#x8BB2;&#x8FF0;&#x7684;<code>def</code>, <code>let</code>,&#x51FD;&#x6570;&#x5B9A;&#x4E49;&#x90FD;&#x662F;&#x5E72;&#x8FD9;&#x4E2A;&#x7684;&#x3002;Clojure&#x7528;<em>&#x7B26;&#x53F7;</em>&#x547D;&#x540D;&#x51FD;&#x6570;&#xFF0C;&#x5B8F;&#xFF0C;&#x6570;&#x636E;&#x548C;&#x4EFB;&#x4F55;&#x5176;&#x4ED6;&#x53EF;&#x7528;&#x7684;&#x4E1C;&#x897F;&#xFF0C;&#x5E76;&#x901A;&#x8FC7;<em>&#x89E3;&#x6790;</em>&#x6765;&#x5BF9;&#x5176;&#x6C42;&#x503C;&#x3002;&#x8981;&#x89E3;&#x6790;&#x4E00;&#x4E2A;&#x7B26;&#x53F7;&#xFF0C;Clojure&#x904D;&#x5386;&#x6240;&#x6709;&#x4F60;&#x5EFA;&#x7ACB;&#x7684;&#x7ED1;&#x5B9A;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x4E00;&#x4E2A;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x91CC;&#x67E5;&#x627E;&#x8FD9;&#x4E2A;&#x7B26;&#x53F7;&#x6761;&#x76EE;&#xFF0C;&#x7B2C;6&#x7AE0;&#x8BB2;&#x89E3;&#x8FC7;&#x8FD9;&#x4E9B;&#x3002;&#x6700;&#x7EC8;&#x4E00;&#x4E2A;&#x7B26;&#x53F7;&#x89E3;&#x6790;&#x6210;&#x4E00;&#x4E2A;<em>&#x503C;</em>&#x6216;&#x4E00;&#x4E2A;<em>&#x7279;&#x6B8A;&#x5F62;&#x5F0F;</em>&#x2013;&#x63D0;&#x4F9B;&#x57FA;&#x7840;&#x884C;&#x4E3A;&#x7684;Clojure&#x5167;&#x5EFA;&#x64CD;&#x4F5C;&#x7B26;&#x3002;</p>
<blockquote>
<p>In general, Clojure resolves a symbol by:</p>
<ol>
<li>Looking up whether the symbol names a special form. If it doesn&#x2019;t . . .</li>
<li>Looking up whether the symbol corresponds to a local binding. If it doesn&#x2019;t . . .</li>
<li>Trying to find a namespace mapping introduced by <code>def</code>. If it doesn&#x2019;t . . .</li>
<li>Throwing an exception</li>
</ol>
</blockquote>
<p>&#x901A;&#x5E38;&#xFF0C;Clojure&#x8FD9;&#x6837;&#x89E3;&#x6790;&#x4E00;&#x4E2A;&#x7B26;&#x53F7;&#xFF1A;</p>
<ol>
<li>&#x67E5;&#x627E;&#x8FD9;&#x4E2A;&#x7B26;&#x53F7;&#x662F;&#x5426;&#x662F;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x2026;</li>
<li>&#x67E5;&#x627E;&#x662F;&#x5426;&#x662F;&#x672C;&#x5730;&#x7ED1;&#x5B9A;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x2026;</li>
<li>&#x5728;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x91CC;&#x67E5;&#x627E;&#x662F;&#x5426;&#x662F;&#x4E00;&#x4E2A;<code>def</code>&#x5B9A;&#x4E49;&#x7684;&#x6620;&#x5C04;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x2026;</li>
<li>&#x629B;&#x51FA;&#x5F02;&#x5E38;</li>
</ol>
<blockquote>
<p>Let&#x2019;s first look at a symbol resolving to a special form. Special forms, like <code>if</code>, are always used in the context of an operation; they&#x2019;re always the first element in a list:</p>
</blockquote>
<p>&#x5148;&#x770B;&#x4E00;&#x4E2A;&#x89E3;&#x6790;&#x6210;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x7684;&#x7B26;&#x53F7;&#x3002;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#xFF0C;&#x6BD4;&#x5982;<code>if</code>,&#x603B;&#x662F;&#x4F5C;&#x4E3A;&#x64CD;&#x4F5C;&#x7B26;&#x4F7F;&#x7528;&#xFF0C;&#x603B;&#x662F;list&#x91CC;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">if</span></span> <span class="literal">true</span> <span class="symbol">:a</span> <span class="symbol">:b</span>)</span><br><span class="line"><span class="comment">; =&gt; :a</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In this case, <code>if</code> is a special form and it&#x2019;s being used as an operator. If you try to refer to a special form outside of this context, you&#x2019;ll get an exception:</p>
</blockquote>
<p>&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;&#xFF0C;<code>if</code>&#x662F;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#xFF0C;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x64CD;&#x4F5C;&#x7B26;&#x4F7F;&#x7528;&#x3002;&#x5982;&#x679C;&#x5728;&#x5176;&#x4ED6;&#x60C5;&#x51B5;&#x4E0B;&#x5F15;&#x7528;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#xFF0C;&#x4F1A;&#x5F15;&#x8D77;&#x5F02;&#x5E38;:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if</span><br><span class="line">; =&gt; CompilerException java.lang.RuntimeException: Unable to resolve symbol: if in this context</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Next, let&#x2019;s evaluate some <em>local bindings</em>. A local binding is any association between a symbol and a value that wasn&#x2019;t created by <code>def</code>. In the next example, the symbol <code>x</code> is bound to 5 using <code>let</code>. When the evaluator resolves <code>x</code>, it resolves the symbol <code>x</code> to the value 5:</p>
</blockquote>
<p>&#x63A5;&#x4E0B;&#x6765;&#xFF0C;&#x6C42;&#x503C;<em>&#x672C;&#x5730;&#x7ED1;&#x5B9A;</em>&#x3002;&#x672C;&#x5730;&#x7ED1;&#x5B9A;&#x662F;&#x4EFB;&#x4F55;&#x975E;<code>def</code>&#x5EFA;&#x7ACB;&#x7684;&#x7B26;&#x53F7;&#x4E0E;&#x503C;&#x7684;&#x5173;&#x8054;&#x3002;&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;&#xFF0C;&#x7B26;&#x53F7;<code>x</code>&#x901A;&#x8FC7;<code>let</code>&#x4E0E;5&#x7ED1;&#x5B9A;&#x3002;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x89E3;&#x6790;<code>x</code>&#x65F6;&#x5019;&#xFF0C;&#x89E3;&#x6790;&#x6210;&#x503C;5:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [x <span class="number">5</span>]</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">3</span>))</span><br><span class="line"><span class="comment">; =&gt; 8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now if we create a namespace mapping of <code>x</code> to 15, Clojure resolves it accordingly:</p>
</blockquote>
<p>&#x5982;&#x679C;&#x5EFA;&#x7ACB;&#x4E00;&#x4E2A;<code>x</code>&#x4E0E;15&#x7684;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x6620;&#x5C04;,Clojure&#x4F1A;&#x76F8;&#x5E94;&#x5730;&#x89E3;&#x6790;&#x5B83;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> x <span class="number">15</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> x <span class="number">3</span>)</span><br><span class="line"><span class="comment">; =&gt; 18</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In the next example, <code>x</code> is mapped to 15, but we introduce a local binding of <code>x</code> to 5 using <code>let</code>. So <code>x</code> is resolved to 5:</p>
</blockquote>
<p>&#x4E0B;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;,<code>x</code>&#x6620;&#x5C04;&#x6210;15,&#x4F46;&#x5728;&#x672C;&#x5730;&#x7ED1;&#x5B9A;&#x91CC;<code>x</code>&#x901A;&#x8FC7;<code>let</code>&#x7ED1;&#x5B9A;&#x4E3A;5,&#x6240;&#x4EE5;<code>x</code>&#x89E3;&#x6790;&#x4E3A;5:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> x <span class="number">15</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [x <span class="number">5</span>]</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">3</span>))</span><br><span class="line"><span class="comment">; =&gt; 8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>You can nest bindings, in which case the most recently defined binding takes precedence:</p>
</blockquote>
<p>&#x4E5F;&#x53EF;&#x4EE5;&#x5D4C;&#x5957;&#x7ED1;&#x5B9A;,&#x6700;&#x5185;&#x90E8;&#x7684;&#x7ED1;&#x5B9A;&#x4F18;&#x5148;&#x7EA7;&#x6700;&#x9AD8;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [x <span class="number">5</span>]</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [x <span class="number">6</span>]</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">3</span>)))</span><br><span class="line"><span class="comment">; =&gt; 9</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Functions also create local bindings, binding parameters to arguments within the function body. In this next example, <code>exclaim</code> is mapped to a function. Within the function body, the parameter name <code>exclamation</code> is bound to the argument passed to the function:</p>
</blockquote>
<p>&#x51FD;&#x6570;&#x4E5F;&#x4F1A;&#x521B;&#x5EFA;&#x672C;&#x5730;&#x7ED1;&#x5B9A;,&#x5728;&#x51FD;&#x6570;&#x4F53;&#x91CC;,&#x628A;&#x53C2;&#x6570;&#x540D;&#x4E0E;&#x53C2;&#x6570;&#x503C;&#x7ED1;&#x5B9A;.&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;,<code>exclaim</code>&#x662F;&#x51FD;&#x6570;.&#x51FD;&#x6570;&#x4F53;&#x91CC;,&#x53C2;&#x6570;&#x540D;<code>exclamation</code>&#x4E0E;&#x4F20;&#x7ED9;&#x51FD;&#x6570;&#x7684;&#x53C2;&#x6570;&#x503C;&#x7ED1;&#x5B9A;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> exclaim</span><br><span class="line">  [exclamation]</span><br><span class="line">  (<span class="name"><span class="builtin-name">str</span></span> exclamation <span class="string">&quot;!&quot;</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">exclaim</span> <span class="string">&quot;Hadoken&quot;</span>)</span><br><span class="line"><span class="comment">; =&gt; &quot;Hadoken!&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Finally, in this last example, <code>map</code> and <code>inc</code> both refer to functions:</p>
</blockquote>
<p>&#x6700;&#x540E;&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;,<code>map</code>&#x548C;<code>inc</code>&#x90FD;&#x662F;&#x51FD;&#x6570;&#x5F15;&#x7528;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">map</span></span> inc [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>])</span><br><span class="line"><span class="comment">; =&gt; (2 3 4)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>When Clojure evaluates this code, it first evaluates the <code>map</code> symbol, looking up the corresponding function and applying it to its arguments. The symbol <code>map</code> refers to the map function, but it shouldn&#x2019;t be confused with the function itself. The <code>map</code> symbol is still a data structure, the same way that the string <code>&quot;fried salad&quot;</code> is a data structure, but it&#x2019;s not the same as the function itself:</p>
</blockquote>
<p>Clojure&#x89E3;&#x6790;&#x8FD9;&#x4E2A;&#x4EE3;&#x7801;&#x65F6;,&#x5148;&#x6C42;&#x503C;<code>map</code>&#x7B26;&#x53F7;,&#x67E5;&#x627E;&#x76F8;&#x5E94;&#x7684;&#x51FD;&#x6570;&#x5E76;&#x7528;&#x5176;&#x53C2;&#x6570;&#x8C03;&#x7528;&#x5B83;.&#x7B26;&#x53F7;<code>map</code>&#x5F15;&#x7528;&#x7684;&#x662F;map&#x51FD;&#x6570;,&#x4F46;&#x4E0D;&#x8981;&#x628A;&#x5B83;&#x4E0E;&#x51FD;&#x6570;&#x81EA;&#x8EAB;&#x6DF7;&#x6DC6;&#x3002;&#x7B26;&#x53F7;<code>map</code>&#x4ECD;&#x7136;&#x662F;&#x6570;&#x636E;&#x7ED3;&#x6784;,&#x5C31;&#x50CF;&#x5B57;&#x7B26;&#x4E32;<code>&quot;fried salad&quot;</code>&#x662F;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4E00;&#x6837;,&#x7B26;&#x53F7;&#x4E0D;&#x662F;&#x51FD;&#x6570;&#x672C;&#x8EAB;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-string</span> <span class="string">&quot;+&quot;</span>)</span><br><span class="line"><span class="comment">; =&gt; +</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">type</span></span> (<span class="name">read-string</span> <span class="string">&quot;+&quot;</span>))</span><br><span class="line"><span class="comment">; =&gt; clojure.lang.Symbol</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">list</span></span> (<span class="name">read-string</span> <span class="string">&quot;+&quot;</span>) <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line"><span class="comment">; =&gt; (+ 1 2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In these examples, you&#x2019;re interacting with the plus symbol, <code>+</code>, as a data structure. You&#x2019;re not interacting with the addition function that it refers to. If you evaluate it, Clojure looks up the function and applies it:</p>
</blockquote>
<p>&#x5728;&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;,&#x4F60;&#x76F4;&#x63A5;&#x4E0E;&#x4F5C;&#x4E3A;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x7B26;&#x53F7;<code>+</code>&#x4EA4;&#x4E92;.&#x4E0D;&#x662F;&#x4E0E;&#x5B83;&#x5F15;&#x7528;&#x7684;&#x52A0;&#x6CD5;&#x51FD;&#x6570;&#x4EA4;&#x4E92;.&#x5982;&#x679C;&#x5BF9;&#x5B83;&#x6C42;&#x503C;,Clojure&#x67E5;&#x627E;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x5E76;&#x8C03;&#x7528;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">eval</span></span> (<span class="name"><span class="builtin-name">list</span></span> (<span class="name">read-string</span> <span class="string">&quot;+&quot;</span>) <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line"><span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>On their own, symbols and their referents don&#x2019;t actually do anything; Clojure performs work by evaluating lists.</p>
</blockquote>
<p>&#x5BF9;&#x4E8E;&#x7B26;&#x53F7;&#x548C;&#x7B26;&#x53F7;&#x7684;&#x5F15;&#x7528;&#x81EA;&#x8EAB;&#x6765;&#x8BF4;,&#x4ED6;&#x4EEC;&#x5B9E;&#x9645;&#x4E0A;&#x4EC0;&#x4E48;&#x4E5F;&#x4E0D;&#x505A;;Clojure&#x9760;&#x6C42;&#x503C;list&#x5E72;&#x6D3B;.</p>
<blockquote>
<p>Lists</p>
</blockquote>
<h3 id="&#x5217;&#x8868;"><a href="#&#x5217;&#x8868;" class="headerlink" title="&#x5217;&#x8868;"></a>&#x5217;&#x8868;</h3><blockquote>
<p>If the data structure is an empty list, it evaluates to an empty list:</p>
</blockquote>
<p>&#x5982;&#x679C;&#x6C42;&#x503C;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x662F;&#x7A7A;list, &#x6C42;&#x503C;&#x7ED3;&#x679C;&#x662F;&#x7A7A;list:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">eval</span></span> (<span class="name">read-string</span> <span class="string">&quot;()&quot;</span>))</span><br><span class="line"><span class="comment">; =&gt; ()</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Otherwise, it is evaluated as a <em>call</em> to the first element in the list. The way the call is performed depends on the nature of that first element.</p>
</blockquote>
<p>&#x5426;&#x5219;,&#x5C31;&#x662F;&#x5BF9;&#x5217;&#x8868;&#x91CC;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x7684;<em>&#x8C03;&#x7528;</em>&#x7684;&#x6C42;&#x503C;.&#x8C03;&#x7528;&#x7684;&#x65B9;&#x6CD5;&#x7531;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x7684;&#x6027;&#x8D28;&#x51B3;&#x5B9A;.</p>
<blockquote>
<p>Function Calls</p>
</blockquote>
<h4 id="&#x51FD;&#x6570;&#x8C03;&#x7528;"><a href="#&#x51FD;&#x6570;&#x8C03;&#x7528;" class="headerlink" title="&#x51FD;&#x6570;&#x8C03;&#x7528;"></a>&#x51FD;&#x6570;&#x8C03;&#x7528;</h4><blockquote>
<p>When performing a function call, each operand is fully evaluated and then passed to the function as an argument. In this example, the <code>+</code> symbol resolves to a function:</p>
</blockquote>
<p>&#x8FDB;&#x884C;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x65F6;,&#x6BCF;&#x4E2A;&#x64CD;&#x4F5C;&#x6570;&#x90FD;&#x5B8C;&#x5168;&#x6C42;&#x503C;,&#x7136;&#x540E;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#x4F20;&#x9012;&#x7ED9;&#x51FD;&#x6570;.&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x4E2D;,&#x7B26;&#x53F7;<code>+</code>&#x89E3;&#x6790;&#x4E3A;&#x51FD;&#x6570;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line"><span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Clojure sees that the list&#x2019;s head is a function, so it proceeds to evaluate the rest of the elements in the list. The operands 1 and 2 both evaluate to themselves, and after they&#x2019;re evaluated, Clojure applies the addition function to them.</p>
</blockquote>
<p>Clojure&#x770B;&#x5230;list&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x662F;&#x4E2A;&#x51FD;&#x6570;,&#x6240;&#x4EE5;&#x5B83;&#x7EE7;&#x7EED;&#x6C42;&#x503C;list&#x91CC;&#x5269;&#x4F59;&#x7684;&#x5143;&#x7D20;.&#x64CD;&#x4F5C;&#x6570;1&#x548C;2&#x90FD;&#x6C42;&#x503C;&#x4E3A;&#x81EA;&#x8EAB;,&#x4E4B;&#x540E;&#x7528;&#x8FD9;&#x4E9B;&#x53C2;&#x6570;&#x8C03;&#x7528;&#x51FD;&#x6570;.</p>
<blockquote>
<p>You can also nest function calls:</p>
</blockquote>
<p>&#x51FD;&#x6570;&#x8C03;&#x7528;&#x4E5F;&#x53EF;&#x80FD;&#x5D4C;&#x5957;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line"><span class="comment">; =&gt; 6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Even though the second argument is a list, Clojure follows the same process here: look up the <code>+</code> symbol and evaluate each argument. To evaluate the list <code>(+ 2 3)</code>, Clojure resolves the first member to the addition function and proceeds to evaluate each of the arguments. In this way, evaluation is recursive.</p>
</blockquote>
<p>&#x5C3D;&#x7BA1;&#x7B2C;&#x4E8C;&#x4E2A;&#x53C2;&#x52A0;&#x662F;&#x4E2A;list,Clojure&#x4ECD;&#x91C7;&#x7528;&#x540C;&#x6837;&#x7684;&#x8FC7;&#x7A0B;: &#x67E5;&#x627E;&#x7B26;&#x53F7;<code>+</code>&#x5E76;&#x6C42;&#x503C;&#x5176;&#x6BCF;&#x4E2A;&#x53C2;&#x6570;.&#x6C42;&#x503C;list<code>(+ 2 3)</code>&#x65F6;,Clojure&#x628A;&#x7B2C;&#x4E00;&#x4E2A;&#x6210;&#x5458;&#x89E3;&#x6790;&#x4E3A;&#x52A0;&#x6CD5;&#x51FD;&#x6570;&#x5E76;&#x7EE7;&#x7EED;&#x6C42;&#x503C;&#x6BCF;&#x4E2A;&#x53C2;&#x6570;.&#x6C42;&#x503C;&#x4EE5;&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x9012;&#x5F52;&#x8FDB;&#x884C;.</p>
<blockquote>
<p>Special Forms</p>
</blockquote>
<h4 id="&#x7279;&#x6B8A;&#x5F62;&#x5F0F;"><a href="#&#x7279;&#x6B8A;&#x5F62;&#x5F0F;" class="headerlink" title="&#x7279;&#x6B8A;&#x5F62;&#x5F0F;"></a>&#x7279;&#x6B8A;&#x5F62;&#x5F0F;</h4><blockquote>
<p>You can also call <em>special forms</em>. In general, special forms are special because they implement core behavior that can&#x2019;t be implemented with functions. For example:</p>
</blockquote>
<p><em>&#x7279;&#x6B8A;&#x5F62;&#x5F0F;</em> &#x4E5F;&#x53EF;&#x4EE5;&#x8C03;&#x7528;.&#x603B;&#x7684;&#x6765;&#x8BF4;,&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x7684;&#x7279;&#x6B8A;&#x4E4B;&#x5904;&#x5728;&#x4E8E;: &#x5B83;&#x4EEC;&#x5B9E;&#x73B0;&#x4E86;&#x51FD;&#x6570;&#x65E0;&#x6CD5;&#x5B9E;&#x73B0;&#x7684;&#x6838;&#x5FC3;&#x529F;&#x80FD;.&#x6BD4;&#x5982;:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">if</span></span> <span class="literal">true</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line"><span class="comment">; =&gt; 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Here, we ask Clojure to evaluate a list beginning with the symbol <code>if</code>. That <code>if</code> symbol gets resolved to the <code>if</code> special form, and Clojure calls that special form with the operands <code>true</code>, <code>1</code>, and <code>2</code>.</p>
</blockquote>
<p>&#x8FD9;&#x91CC;,Clojure&#x6C42;&#x503C;&#x4E86;&#x4E00;&#x4E2A;&#x4EE5;&#x7B26;&#x53F7;<code>if</code>&#x5F00;&#x59CB;&#x7684;list&#x3002;&#x8FD9;&#x4E2A;<code>if</code>&#x7B26;&#x53F7;&#x89E3;&#x6790;&#x4E3A;<code>if</code>&#x7279;&#x6B8A;&#x5F62;&#x5F0F;,Clojure&#x7528;&#x64CD;&#x4F5C;&#x6570;<code>true</code>, <code>1</code>, <code>2</code>&#x8C03;&#x7528;&#x8FD9;&#x4E2A;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x3002;</p>
<blockquote>
<p>Special forms don&#x2019;t follow the same evaluation rules as normal functions. For example, when you call a function, each operand gets evaluated. However, with <code>if</code> you don&#x2019;t want each operand to be evaluated. You only want certain operands to be evaluated, depending on whether the condition is true or false.</p>
</blockquote>
<p>&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x4E0D;&#x9075;&#x4ECE;&#x666E;&#x901A;&#x51FD;&#x6570;&#x7684;&#x6C42;&#x503C;&#x89C4;&#x5219;&#x3002;&#x6BD4;&#x5982;&#xFF0C;&#x8C03;&#x7528;&#x51FD;&#x6570;&#x65F6;&#xFF0C;&#x6BCF;&#x4E2A;&#x64CD;&#x4F5C;&#x6570;&#x90FD;&#x88AB;&#x6C42;&#x503C;&#x3002;&#x4F46;&#x5BF9;&#x4E8E;<code>if</code>,&#x4E0D;&#x5E0C;&#x671B;&#x6BCF;&#x4E2A;&#x64CD;&#x4F5C;&#x6570;&#x90FD;&#x88AB;&#x6C42;&#x503C;&#x3002;&#x53EA;&#x5E0C;&#x671B;&#x6839;&#x636E;&#x6761;&#x4EF6;&#x662F;&#x5426;&#x4E3A;true&#x6216;false,&#x67D0;&#x4E2A;&#x64CD;&#x4F5C;&#x6570;&#x88AB;&#x6C42;&#x503C;&#x3002;</p>
<blockquote>
<p>Another important special form is <code>quote</code>. You&#x2019;ve seen lists represented like this:</p>
</blockquote>
<p>&#x53E6;&#x4E00;&#x4E2A;&#x91CD;&#x8981;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x662F;<code>&#x5F15;&#x7528;</code>(quote)&#x3002;&#x4F60;&#x5DF2;&#x7ECF;&#x89C1;&#x8FC7;&#x8FD9;&#x4E48;&#x8868;&#x793A;&#x7684;list:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;(a b c)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>As you saw in &#x201C;The Reader&#x201D; on page 153, this invokes a reader macro so that we end up with this:</p>
</blockquote>
<p>&#x524D;&#x9762;&#x89C1;&#x8FC7;&#xFF0C;&#x8FD9;&#x4F1A;&#x8C03;&#x7528;&#x4F1A;&#x4F7F;&#x7528;&#x4E00;&#x4E2A;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x5B8F;&#x6700;&#x7EC8;&#x5F97;&#x5230;&#x8FD9;&#x4E2A;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">quote</span></span> (<span class="name">a</span> b c))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Normally, Clojure would try to resolve the <code>a</code> symbol and then call it because it&#x2019;s the first element in a list. The <code>quote</code> special form tells the evaluator, &#x201C;Instead of evaluating my next data structure like normal, just return the data structure itself.&#x201D; In this case, you end up with a list consisting of the symbols <code>a</code>, <code>b</code>, and <code>c</code>.</p>
</blockquote>
<p>&#x901A;&#x5E38;&#xFF0C;&#x56E0;&#x4E3A;&#x7B26;&#x53F7;<code>a</code>&#x662F;list&#x7B2C;&#x4E00;&#x4E2A;&#x6210;&#x5458;&#xFF0C;Clojure&#x4F1A;&#x5C1D;&#x8BD5;&#x89E3;&#x6790;&#x5E76;&#x8C03;&#x7528;&#x5B83;&#x3002;<code>&#x5F15;&#x7528;</code>&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x7684;&#x7528;&#x5904;&#x662F;&#x544A;&#x8BC9;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#xFF0C;&#x4E0D;&#x8981;&#x6C42;&#x503C;&#x4E0B;&#x4E00;&#x4E2A;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x8FD9;&#x4E2A;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x81EA;&#x8EAB;&#x3002;&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;&#xFF0C;&#x5C31;&#x662F;&#x4E2A;&#x7B26;&#x53F7;<code>a</code>,<code>b</code>,<code>c</code>&#x7EC4;&#x6210;&#x7684;list&#x3002;</p>
<blockquote>
<p><code>def</code>, <code>let</code>, <code>loop</code>, <code>fn</code>, <code>do</code>, and <code>recur</code> are all special forms as well. You can see why: they don&#x2019;t get evaluated the same way as functions. For example, normally when the evaluator evaluates a symbol, it resolves that symbol, but <code>def</code> and <code>let</code> obviously don&#x2019;t behave that way. Instead of resolving symbols, they actually create associations between symbols and values. So the evaluator receives a combination of data structures from the reader, and it goes about resolving the symbols and calling the functions or special forms at the beginning of each list. But there&#x2019;s more! You can also place a <em>macro</em> at the beginning of a list instead of a function or a special form, and this can give you tremendous power over how the rest of the data structures are evaluated.</p>
</blockquote>
<p><code>def</code>, <code>let</code>, <code>loop</code>, <code>fn</code>, <code>do</code> &#x548C; <code>recur</code>&#x90FD;&#x662F;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x3002;&#x539F;&#x56E0;&#x662F;&#x4ED6;&#x4EEC;&#x4E0E;&#x51FD;&#x6570;&#x7684;&#x6C42;&#x503C;&#x65B9;&#x6CD5;&#x4E0D;&#x540C;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x6C42;&#x503C;&#x4E00;&#x4E2A;&#x7B26;&#x53F7;&#x65F6;&#xFF0C;&#x4F1A;&#x89E3;&#x6790;&#x90A3;&#x4E2A;&#x7B26;&#x53F7;&#xFF0C;&#x4F46;<code>def</code>&#x548C;<code>let</code>&#x660E;&#x663E;&#x4E0D;&#x662F;&#x8FD9;&#x6837;&#xFF0C;&#x800C;&#x662F;&#x521B;&#x5EFA;&#x4E86;&#x7B26;&#x53F7;&#x4E0E;&#x503C;&#x7684;&#x5173;&#x8054;&#x3002;&#x5C31;&#x662F;&#x8FD9;&#x6837;&#xFF1A;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x4ECE;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x63A5;&#x53D7;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x5E76;&#x89E3;&#x6790;&#x5176;&#x4E2D;&#x7684;&#x7B26;&#x53F7;&#xFF0C;&#x5E76;&#x8C03;&#x7528;&#x6BCF;&#x4E2A;list&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#x6216;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x3002;&#x4F46;&#x8FD8;&#x6CA1;&#x5B8C;&#xFF01;list&#x7B2C;&#x4E00;&#x4E2A;&#x6210;&#x5458;&#x9664;&#x4E86;&#x662F;&#x51FD;&#x6570;&#x6216;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#xFF0C;&#x8FD8;&#x53EF;&#x4EE5;&#x662F;<em>&#x5B8F;</em>&#xFF0C;&#x5B8F;&#x8D4B;&#x4E88;&#x4F60;&#x6781;&#x5176;&#x5F3A;&#x5927;&#x7684;&#x5BF9;&#x4E8E;&#x5176;&#x540E;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x5982;&#x4F55;&#x6C42;&#x503C;&#x7684;&#x80FD;&#x529B;&#x3002;</p>
<blockquote>
<p>Macros</p>
</blockquote>
<h4 id="&#x5B8F;"><a href="#&#x5B8F;" class="headerlink" title="&#x5B8F;"></a>&#x5B8F;</h4><blockquote>
<p>Hmm . . . Clojure evaluates data structures&#x2014;the same data structures that we write and manipulate in our Clojure programs. Wouldn&#x2019;t it be awesome if we could use Clojure to manipulate the data structures that Clojure evaluates? Yes, yes it would! And guess what? You can do this with macros! Did your head just explode? Mine did!</p>
</blockquote>
<p>Clojure&#x6C42;&#x503C;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x548C;&#x6211;&#x4EEC;&#x5199;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x662F;&#x4E00;&#x6837;&#x7684;&#x3002;&#x5982;&#x679C;&#x80FD;&#x591F;&#x4FEE;&#x6539;Clojure&#x6C42;&#x503C;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x662F;&#x4E0D;&#x662F;&#x5F88;&#x68D2;&#x5462;&#xFF1F;&#x5B8F;&#x5C31;&#x662F;&#x5E72;&#x8FD9;&#x4E2A;&#x7684;&#xFF01;&#x5B8F;&#x53EF;&#x4EE5;&#x64CD;&#x7EB5;Clojure&#x6C42;&#x503C;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;!</p>
<blockquote>
<p>To get an idea of what macros do, let&#x2019;s look at some code. Say we want to write a function that makes Clojure read infix notation (such as <code>1 + 1</code>) instead of its normal notation with the operator first (<code>+ 1 1</code>). This example is not a macro. Rather, it merely shows that you can write code using infix notation and then use Clojure to transform it so it will actually execute. First, create a list that represents infix addition:</p>
</blockquote>
<p>&#x4E3A;&#x4E86;&#x611F;&#x53D7;&#x4E00;&#x4E0B;&#x5B8F;&#x4F7F;&#x5E72;&#x5565;&#x7684;&#xFF0C;&#x6765;&#x770B;&#x4E2A;&#x4F8B;&#x5B50;&#x3002;&#x6BD4;&#x5982;&#x8BF4;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#xFF0C;&#x4F7F;&#x6211;&#x4EEC;&#x80FD;&#x8BFB;&#x53D6;&#x4E2D;&#x7F6E;&#x8868;&#x793A;&#x6CD5;(&#x6BD4;&#x5982;<code>1 + 1</code>),&#x800C;&#x4E0D;&#x662F;&#x6B63;&#x5E38;&#x7684;&#x524D;&#x7F6E;&#x8868;&#x793A;&#x6CD5;(<code>+ 1 1</code>)&#x3002;&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x4E0D;&#x662F;&#x5B8F;&#xFF0C;&#x53EA;&#x662F;&#x8BA9;&#x4F60;&#x77E5;&#x9053;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x5199;&#x4E2D;&#x7F6E;&#x8868;&#x793A;&#x6CD5;&#x7684;&#x4EE3;&#x7801;&#xFF0C;&#x7136;&#x540E;&#x8F6C;&#x6362;&#x6210;&#x53EF;&#x4EE5;&#x6267;&#x884C;&#x7684;&#x4EE3;&#x7801;&#x3002;&#x9996;&#x5148;&#x5EFA;&#x7ACB;&#x4E00;&#x4E2A;&#x4E2D;&#x7F6E;&#x52A0;&#x6CD5;list&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">read-string</span> <span class="string">&quot;(1 + 1)&quot;</span>)</span><br><span class="line"><span class="comment">; =&gt; (1 + 1)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Clojure will throw an exception if you try to make it evaluate this list:</p>
</blockquote>
<p>&#x5982;&#x679C;&#x4F60;&#x5BF9;&#x8FD9;&#x4E2A;list&#x6C42;&#x503C;&#xFF0C;&#x4F1A;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">eval</span></span> (<span class="name">read-string</span> <span class="string">&quot;(1 + 1)&quot;</span>))</span><br><span class="line"><span class="comment">; =&gt; ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>However, <code>read-string</code> returns a list, and you can use Clojure to reorganize that list into something it <code>can</code> successfully evaluate:</p>
</blockquote>
<p>&#x4F46;<code>read-string</code>&#x8FD4;&#x56DE;&#x7684;&#x662F;list,&#x4F60;&#x53EF;&#x4EE5;&#x91CD;&#x7EC4;&#x8FD9;&#x4E2A;list&#xFF0C;&#x4F7F;&#x5B83;<code>&#x80FD;&#x591F;</code>&#x6210;&#x529F;&#x6C42;&#x503C;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [infix (<span class="name">read-string</span> <span class="string">&quot;(1 + 1)&quot;</span>)]</span><br><span class="line">  (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">second</span></span> infix) (<span class="name"><span class="builtin-name">first</span></span> infix) (<span class="name"><span class="builtin-name">last</span></span> infix)))</span><br><span class="line"><span class="comment">; =&gt; (+ 1 1)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>If you eval this, it returns 2, just as you&#x2019;d expect:</p>
</blockquote>
<p>&#x5982;&#x679C;&#x6C42;&#x503C;&#xFF0C;&#x4F1A;&#x8FD4;&#x56DE;2&#xFF0C;&#x5982;&#x4F60;&#x6240;&#x613F;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">eval</span></span></span><br><span class="line"> (<span class="name"><span class="builtin-name">let</span></span> [infix (<span class="name">read-string</span> <span class="string">&quot;(1 + 1)&quot;</span>)]</span><br><span class="line">   (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">second</span></span> infix) (<span class="name"><span class="builtin-name">first</span></span> infix) (<span class="name"><span class="builtin-name">last</span></span> infix))))</span><br><span class="line"><span class="comment">; =&gt; 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>This is cool, but it&#x2019;s also quite clunky. That&#x2019;s where macros come in. Macros give you a convenient way to manipulate lists before Clojure evaluates them. Macros are a lot like functions: they take arguments and return a value, just like a function would. They work on Clojure data structures, just like functions do. What makes them unique and powerful is the way they fit in to the evaluation process. They are executed in between the reader and the evaluator&#x2014;so they can manipulate the data structures that the reader spits out and transform with those data structures before passing them to the evaluator.</p>
</blockquote>
<p>&#x8FD9;&#x5F88;&#x9177;&#xFF0C;&#x4F46;&#x5F88;&#x9EBB;&#x70E6;&#x3002;&#x5B8F;&#x5C31;&#x662F;&#x4E3A;&#x4E86;&#x89E3;&#x51B3;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;&#x3002;Clojure&#x6C42;&#x503C;list&#x4E4B;&#x524D;&#xFF0C;&#x7528;&#x5B8F;&#x53EF;&#x4EE5;&#x65B9;&#x4FBF;&#x5730;&#x64CD;&#x7EB5;&#x5B83;&#x3002;&#x5B8F;&#x5F88;&#x50CF;&#x51FD;&#x6570;&#xFF1A;&#x63A5;&#x53D7;&#x53C2;&#x6570;&#xFF0C;&#x8FD4;&#x56DE;&#x503C;&#x3002;&#x5B8F;&#x50CF;&#x51FD;&#x6570;&#x4E00;&#x6837;&#xFF0C;&#x4E5F;&#x5BF9;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x8D77;&#x4F5C;&#x7528;&#x3002;&#x5B8F;&#x7684;&#x72EC;&#x7279;&#x548C;&#x5F3A;&#x5927;&#x4E4B;&#x5904;&#x5728;&#x4E8E;&#x5B83;&#x5982;&#x4F55;&#x878D;&#x5165;&#x6C42;&#x503C;&#x8FC7;&#x7A0B;&#x3002;&#x5B8F;&#x6267;&#x884C;&#x4E8E;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x548C;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x4E4B;&#x95F4;&#x2013;&#x6240;&#x4EE5;&#x5B8F;&#x80FD;&#x64CD;&#x7EB5;&#x5E76;&#x8F6C;&#x6362;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x751F;&#x6210;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x4F20;&#x7ED9;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x3002;</p>
<blockquote>
<p>Let&#x2019;s look at an example:</p>
</blockquote>
<p>&#x770B;&#x4E2A;&#x4F8B;&#x5B50;&#xFF1A;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(defmacro ignore-last-operand</span><br><span class="line">  [function-call]</span><br><span class="line">  (butlast function-call))</span><br><span class="line"></span><br><span class="line">&#x278A; (ignore-last-operand (+ 1 2 10))</span><br><span class="line">; =&gt; 3</span><br><span class="line"></span><br><span class="line">;; This will not print anything</span><br><span class="line">(ignore-last-operand (+ 1 2 (println &quot;look at me!!!&quot;)))</span><br><span class="line">; =&gt; 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>At &#x278A; the macro <code>ignore-last-operand</code> receives the list <code>(+ 1 2 10)</code> as its argument, not the value 13. This is very different from a function call, because function calls always evaluate all of the arguments passed in, so there is no possible way for a function to reach into one of its operands and alter or ignore it. By contrast, when you call a macro, the operands are not evaluated. In particular, symbols are not resolved; they are passed as symbols. Lists are not evaluated either; that is, the first element in the list is not called as a function, special form, or macro. Rather, the unevaluated list data structure is passed in.</p>
</blockquote>
<p>&#x5728; &#x278A; &#x5904;&#xFF0C;&#x5B8F;<code>ignore-last-operand</code>&#x63A5;&#x53D7;&#x4E86;&#x7684;&#x53C2;&#x6570;&#x662F;list<code>(+ 1 2 10)</code>&#xFF0C;&#x800C;&#x4E0D;&#x662F;13&#x3002;&#x8FD9;&#x4E0E;&#x51FD;&#x6570;&#x5F88;&#x4E0D;&#x540C;&#xFF0C;&#x56E0;&#x4E3A;&#x51FD;&#x6570;&#x603B;&#x662F;&#x6C42;&#x503C;&#x6240;&#x6709;&#x4F20;&#x5165;&#x7684;&#x53C2;&#x6570;&#xFF0C;&#x6240;&#x4EE5;&#x51FD;&#x6570;&#x65E0;&#x6CD5;&#x5FFD;&#x7565;&#x6216;&#x4FEE;&#x6539;&#x67D0;&#x4E2A;&#x53C2;&#x6570;&#x3002;&#x4E0E;&#x4E4B;&#x76F8;&#x53CD;&#xFF0C;&#x5B8F;&#x4E0D;&#x5BF9;&#x53C2;&#x6570;&#x6C42;&#x503C;&#x3002;&#x7279;&#x522B;&#x662F;&#x5B8F;&#x4E0D;&#x5BF9;&#x7B26;&#x53F7;&#x6C42;&#x503C;&#xFF0C;&#x7B26;&#x53F7;&#x4F20;&#x7ED9;&#x5B8F;&#x8FD8;&#x662F;&#x7B26;&#x53F7;&#x3002;&#x5B8F;&#x4E5F;&#x4E0D;&#x5BF9;list&#x6C42;&#x503C;&#xFF0C;&#x5373;list&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x6210;&#x5458;&#x4E0D;&#x4F1A;&#x4F5C;&#x4E3A;&#x51FD;&#x6570;&#xFF0C;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x6216;&#x5B8F;&#x88AB;&#x8C03;&#x7528;&#xFF0C;&#x4F20;&#x7ED9;&#x5B8F;&#x7684;&#x8FD8;&#x662F;&#x672A;&#x6C42;&#x503C;&#x7684;list&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;</p>
<blockquote>
<p>Another difference is that the data structure returned by a function is not evaluated, but the data structure returned by a macro <code>is</code>. The process of determining the return value of a macro is called <code>macro expansion</code>, and you can use the function <code>macroexpand</code> to see what data structure a macro returns before that data structure is evaluated. Note that you have to quote the form that you pass to <code>macroexpand</code>:</p>
</blockquote>
<p>&#x53E6;&#x4E00;&#x4E2A;&#x5DEE;&#x522B;&#x662F;&#x51FD;&#x6570;&#x8FD4;&#x56DE;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4E0D;&#x88AB;&#x6C42;&#x503C;&#xFF0C;&#x5B8F;&#x8FD4;&#x56DE;&#x7684;<code>&#x88AB;&#x6C42;&#x503C;</code>&#x3002;&#x5B8F;&#x8FD4;&#x56DE;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x8FC7;&#x7A0B;&#x53EB;<code>&#x5B8F;&#x5C55;&#x5F00;</code>&#xFF0C;&#x5E76;&#x4E14;&#x5728;&#x8FD9;&#x4E2A;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x88AB;&#x6C42;&#x503C;&#x4E4B;&#x524D;&#xFF0C;&#x53EF;&#x4EE5;&#x7528;&#x51FD;&#x6570;<code>macroexpand</code>&#x770B;&#x8FD4;&#x56DE;&#x7ED3;&#x679C;&#x3002;&#x6CE8;&#x610F;&#xFF0C;&#x4F20;&#x7ED9;<code>macroexpand</code>&#x7684;&#x5F62;&#x5F0F;&#x5FC5;&#x987B;&#x7528;quote&#x5305;&#x4F4F;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">macroexpand</span></span> &apos;(<span class="name">ignore-last-operand</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">10</span>)))</span><br><span class="line"><span class="comment">; =&gt; (+ 1 2)</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">macroexpand</span></span> &apos;(<span class="name">ignore-last-operand</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span> (<span class="name">println</span> <span class="string">&quot;look at me!!!&quot;</span>))))</span><br><span class="line"><span class="comment">; =&gt; (+ 1 2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>As you can see, both expansions result in the list <code>(+ 1 2)</code>. When this list is evaluated, as in the previous example, the result is <code>3</code>.</p>
</blockquote>
<p>&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x4E24;&#x4E2A;&#x5C55;&#x5F00;&#x7ED3;&#x679C;&#x90FD;&#x662F;list<code>(+ 1 2)</code>&#x3002;&#x5F53;&#x8FD9;&#x4E2A;list&#x88AB;&#x6C42;&#x503C;&#x65F6;&#x5019;&#xFF0C;&#x7ED3;&#x679C;&#x662F;<code>3</code>&#x3002;</p>
<blockquote>
<p>Just for fun, here&#x2019;s a macro for doing simple infix notation:</p>
</blockquote>
<p>&#x53EA;&#x662F;&#x4E3A;&#x4E86;&#x597D;&#x73A9;&#xFF0C;&#x8FD9;&#x4E2A;&#x5B8F;&#x5B9E;&#x73B0;&#x7B80;&#x5355;&#x7684;&#x4E2D;&#x7F6E;&#x8868;&#x793A;&#x6CD5;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> infix</span><br><span class="line">  [infixed]</span><br><span class="line">  (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">second</span></span> infixed)</span><br><span class="line">        (<span class="name"><span class="builtin-name">first</span></span> infixed)</span><br><span class="line">        (<span class="name"><span class="builtin-name">last</span></span> infixed)))</span><br><span class="line"></span><br><span class="line">(<span class="name">infix</span> (<span class="number">1</span> + <span class="number">2</span>))</span><br><span class="line"><span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The best way to think about this whole process is to picture a phase between reading and evaluation: the <code>macro expansion</code> phase. Figure 7-6 shows how you can visualize the entire evaluation process for <code>(infix (1 + 2))</code>.</p>
</blockquote>
<p>&#x601D;&#x8003;&#x6574;&#x4E2A;&#x8FC7;&#x7A0B;&#x7684;&#x6700;&#x597D;&#x65B9;&#x6CD5;&#x662F;&#x5728;&#x56FE;&#x4E0A;&#x7684;&#x8BFB;&#x5165;&#x548C;&#x6C42;&#x503C;&#x9636;&#x6BB5;&#x4E2D;&#x95F4;&#x753B;&#x51FA;<code>&#x5B8F;&#x5C55;&#x5F00;</code>&#x9636;&#x6BB5;&#x3002;&#x56FE;7-6&#x6F14;&#x793A;&#x4E86;<code>(infix (1 + 2))</code>&#x7684;&#x6574;&#x4E2A;&#x6C42;&#x503C;&#x8FC7;&#x7A0B;&#x3002;</p>
<p>&#x56FE;7-6<img src="http://www.braveclojure.com/assets/images/cftbat/read-and-eval/whole-shebang.png" alt="7-6"></p>
<blockquote>
<p>And that&#x2019;s how macros fit into the evaluation process. But why would you want to do this? The reason is that macros allow you to transform an arbitrary data structure like <code>(1 + 2)</code> into one that can Clojure can evaluate, <code>(+ 1 2)</code>. That means <code>you can use Clojure to extend itself</code> so you can write programs however you please. In other words, macros enable <code>syntactic abstraction</code>. Syntactic abstraction may sound a bit abstract (ha ha!), so let&#x2019;s explore that a little.</p>
</blockquote>
<p>&#x8FD9;&#x5C31;&#x662F;&#x5B8F;&#x878D;&#x5165;&#x6C42;&#x503C;&#x8FC7;&#x7A0B;&#x7684;&#x65B9;&#x5F0F;&#x3002;&#x4F46;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x8FD9;&#x4E48;&#x5E72;&#x5462;&#xFF1F;&#x56E0;&#x4E3A;&#x5B8F;&#x53EF;&#x4EE5;&#x628A;&#x4EFB;&#x610F;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x6BD4;&#x5982;<code>(1 + 2)</code>,&#x8F6C;&#x6362;&#x6210;Clojure&#x80FD;&#x6C42;&#x503C;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;<code>(+ 1 2)</code>&#x3002;&#x8FD9;&#x610F;&#x5473;&#x7740;&#x53EF;&#x4EE5;<code>&#x7528;Clojure&#x8BED;&#x8A00;&#x6269;&#x5C55;&#x81EA;&#x8EAB;</code>&#xFF0C;&#x53EA;&#x8981;&#x4F60;&#x9AD8;&#x5174;&#xFF0C;&#x7A0B;&#x5E8F;&#x7231;&#x600E;&#x4E48;&#x5199;&#x600E;&#x4E48;&#x5199;&#x3002;&#x6362;&#x53E5;&#x8BDD;&#x8BF4;&#xFF0C;Clojure&#x5141;&#x8BB8;&#x4F60;&#x8FDB;&#x884C;<code>&#x8BED;&#x6CD5;&#x62BD;&#x8C61;</code>&#x3002;&#x8BED;&#x6CD5;&#x62BD;&#x8C61;&#x542C;&#x8D77;&#x6765;&#x6709;&#x70B9;&#x62BD;&#x8C61;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x63A2;&#x7D22;&#x4E00;&#x4E0B;&#x3002;</p>
<blockquote>
<p>Syntactic Abstraction and the -&gt; Macro</p>
</blockquote>
<h4 id="&#x8BED;&#x6CD5;&#x62BD;&#x8C61;&#x4E0E;-gt-&#x5B8F;"><a href="#&#x8BED;&#x6CD5;&#x62BD;&#x8C61;&#x4E0E;-gt-&#x5B8F;" class="headerlink" title="&#x8BED;&#x6CD5;&#x62BD;&#x8C61;&#x4E0E; -&gt; &#x5B8F;"></a>&#x8BED;&#x6CD5;&#x62BD;&#x8C61;&#x4E0E; -&gt; &#x5B8F;</h4><blockquote>
<p>Often, Clojure code consists of a bunch of nested function calls. For example, I use the following function in one of my projects:</p>
</blockquote>
<p>Clojure&#x4EE3;&#x7801;&#x7ECF;&#x5E38;&#x7531;&#x5927;&#x91CF;&#x5D4C;&#x5957;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x6784;&#x6210;&#x3002;&#x6BD4;&#x5982;&#x4E0B;&#x9762;&#x662F;&#x4E00;&#x4E2A;&#x7528;&#x5728;&#x6211;&#x9879;&#x76EE;&#x91CC;&#x7684;&#x51FD;&#x6570;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> read-resource</span><br><span class="line">  <span class="string">&quot;Read a resource into a string&quot;</span></span><br><span class="line">  [path]</span><br><span class="line">  (<span class="name">read-string</span> (<span class="name"><span class="builtin-name">slurp</span></span> (<span class="name">clojure.java.io/resource</span> path))))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>To understand the function body, you have to find the innermost form, in this case <code>(clojure.java.io/resource path)</code>, and then work your way outward from right to left to see how the result of each function gets passed to another function. This right-to-left flow is opposite of what non-Lisp programmers are used to. As you get used to writing in Clojure, this kind of code gets easier and easier to understand. But if you want to translate Clojure code so you can read it in a more familiar, left-to-right, top-to-bottom manner, you can use the built-in <code>-&gt;</code> macro, which is also known as the <code>threading</code> or <code>stabby</code> macro. It lets you rewrite the preceding function like this:</p>
</blockquote>
<p>&#x8981;&#x7406;&#x89E3;&#x51FD;&#x6570;&#x4F53;&#xFF0C;&#x4F60;&#x5FC5;&#x987B;&#x627E;&#x5230;&#x6700;&#x91CC;&#x9762;&#x7684;&#x5F62;&#x5F0F;&#xFF0C;&#x8FD9;&#x91CC;&#x662F;<code>(clojure.java.io/resource path)</code>,&#x7136;&#x540E;&#x4ECE;&#x53F3;&#x81F3;&#x5DE6;&#x5730;&#x5F80;&#x5916;&#x5C42;&#x8D70;&#xFF0C;&#x67E5;&#x770B;&#x6BCF;&#x4E2A;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x7684;&#x7ED3;&#x679C;&#x662F;&#x5982;&#x4F55;&#x4F20;&#x7ED9;&#x4E0B;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x3002;&#x8FD9;&#x79CD;&#x4ECE;&#x53F3;&#x5F80;&#x5DE6;&#x7684;&#x8FC7;&#x7A0B;&#x4E0E;&#x975E;Lisp&#x7A0B;&#x5E8F;&#x5458;&#x4E60;&#x60EF;&#x7684;&#x8FC7;&#x7A0B;&#x76F8;&#x53CD;&#x3002;&#x5982;&#x679C;&#x4F60;&#x4E60;&#x60EF;&#x4E86;Clojure&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x4EE3;&#x7801;&#x5C31;&#x4F1A;&#x8D8A;&#x6765;&#x8D8A;&#x5BB9;&#x6613;&#x7406;&#x89E3;&#x3002;&#x4F46;&#x5982;&#x679C;&#x4F60;&#x60F3;&#x8F6C;&#x6362;Clojure&#x4EE3;&#x7801;&#xFF0C;&#x8BA9;&#x4F60;&#x7528;&#x66F4;&#x4E60;&#x60EF;&#x7684;&#xFF0C;&#x4ECE;&#x5DE6;&#x5230;&#x53F3;&#xFF0C;&#x4ECE;&#x4E0A;&#x5230;&#x4E0B;&#x7684;&#x65B9;&#x5F0F;&#x9605;&#x8BFB;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x7528;&#x5167;&#x5EFA;&#x7684;<code>-&gt;</code>&#x5B8F;&#x505A;&#x5230;&#xFF0C;&#x8FD9;&#x4E2A;&#x5B8F;&#x4E5F;&#x53EB;<code>&#x7A7F;&#x7EBF;</code>&#x6216;<code>&#x7A7F;&#x4E32;</code>&#x5B8F;&#x3002;&#x524D;&#x9762;&#x7684;&#x51FD;&#x6570;&#x53EF;&#x4EE5;&#x8FD9;&#x4E48;&#x5199;&#xFF1A;</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> read-resource</span><br><span class="line">  [path]</span><br><span class="line">  (<span class="name"><span class="builtin-name">-&gt;</span></span> path</span><br><span class="line">      clojure.java.io/resource</span><br><span class="line">      slurp</span><br><span class="line">      read-string))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>You can read this as a pipeline that goes from top to bottom instead of from inner parentheses to outer parentheses. First, <code>path</code> gets passed to <code>io/resource</code>, then the result gets passed to <code>slurp</code>, and finally the result of that gets passed to <code>read-string</code>.</p>
</blockquote>
<p>&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x4ECE;&#x4E0A;&#x5230;&#x4E0B;&#x7684;&#x7BA1;&#x9053;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x4ECE;&#x5185;&#x5230;&#x5916;&#x7684;&#x62EC;&#x53F7;&#x3002;&#x9996;&#x5148;&#xFF0C;<code>path</code>&#x88AB;&#x4F20;&#x7ED9;<code>io/resource</code>,&#x7136;&#x540E;&#x7ED3;&#x679C;&#x88AB;&#x4F20;&#x7ED9;<code>slurp</code>,&#x6700;&#x540E;&#x53C8;&#x88AB;&#x4F20;&#x7ED9;<code>read-string</code>&#x3002;</p>
<blockquote>
<p>These two ways of defining <code>read-resource</code> are entirely equivalent. However, the second one might be easier understand because we can approach it from top to bottom, a direction we&#x2019;re used to. The <code>-&gt;</code> also lets us omit parentheses, which means there&#x2019;s less visual noise to contend with. This is a <code>syntactic abstraction</code> because it lets you write code in a syntax that&#x2019;s different from Clojure&#x2019;s built-in syntax but is preferable for human consumption. Better than lead into gold!!!</p>
</blockquote>
<p>&#x7528;&#x8FD9;&#x4E24;&#x79CD;&#x65B9;&#x6CD5;&#x5B9A;&#x4E49;<code>read-resource</code>&#x5B8C;&#x5168;&#x4E00;&#x6837;&#x3002;&#x4F46;&#x7B2C;&#x4E8C;&#x79CD;&#x53EF;&#x80FD;&#x66F4;&#x5BB9;&#x6613;&#x7406;&#x89E3;&#xFF0C;&#x56E0;&#x4E3A;&#x53EF;&#x4EE5;&#x7528;&#x4E60;&#x60EF;&#x7684;&#x4ECE;&#x4E0A;&#x5230;&#x4E0B;&#x7684;&#x65B9;&#x5411;&#x3002;<code>-&gt;</code>&#x8FD8;&#x7701;&#x53BB;&#x4E86;&#x62EC;&#x53F7;&#xFF0C;&#x89C6;&#x89C9;&#x4E0A;&#x66F4;&#x6E05;&#x6670;&#x3002;&#x8FD9;&#x662F;&#x4E2A;<code>&#x8BED;&#x6CD5;&#x62BD;&#x8C61;</code>&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4F7F;&#x6211;&#x4EEC;&#x80FD;&#x591F;&#x7528;&#x4E0E;Clojure&#x5185;&#x7F6E;&#x8BED;&#x6CD5;&#x4E0D;&#x540C;&#xFF0C;&#x4F46;&#x4EBA;&#x7C7B;&#x66F4;&#x559C;&#x6B22;&#x7684;&#x65B9;&#x5F0F;&#x5199;&#x4EE3;&#x7801;&#x3002;&#x771F;&#x5C4C;&#xFF01;</p>
<blockquote>
<p>Summary</p>
</blockquote>
<h2 id="&#x603B;&#x7ED3;"><a href="#&#x603B;&#x7ED3;" class="headerlink" title="&#x603B;&#x7ED3;"></a>&#x603B;&#x7ED3;</h2><blockquote>
<p>In this chapter, you learned about Clojure&#x2019;s evaluation process. First, the reader transforms text into Clojure data structures. Next, the macro expander transforms those data structures with macros, converting your custom syntax into syntactically valid data structures. Finally, those data structures get sent to the evaluator. The evaluator processes data structures based on their type: symbols are resolved to their referents; lists result in function, macro, or special form calls; and everything else evaluates to itself.</p>
</blockquote>
<p>&#x8FD9;&#x7AE0;&#x8BB2;&#x8FF0;&#x4E86;Clojure&#x7684;&#x6C42;&#x503C;&#x8FC7;&#x7A0B;&#x3002;&#x9996;&#x5148;&#xFF0C;&#x8BFB;&#x5165;&#x7A0B;&#x5E8F;&#x628A;&#x6587;&#x672C;&#x8F6C;&#x6362;&#x6210;Clojure&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x5B8F;&#x5C55;&#x5F00;&#x7A0B;&#x5E8F;&#x7528;&#x5B8F;&#x8F6C;&#x6362;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x628A;&#x81EA;&#x5B9A;&#x4E49;&#x8BED;&#x6CD5;&#x8F6C;&#x6362;&#x6210;&#x8BED;&#x6CD5;&#x5408;&#x6CD5;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;&#x6700;&#x540E;&#xFF0C;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x88AB;&#x4F20;&#x7ED9;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x3002;&#x6C42;&#x503C;&#x7A0B;&#x5E8F;&#x57FA;&#x4E8E;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x7C7B;&#x578B;&#x5904;&#x7406;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF1A;&#x7B26;&#x53F7;&#x88AB;&#x89E3;&#x6790;&#x6210;&#x7B26;&#x53F7;&#x7684;&#x5F15;&#x7528;&#xFF1B;list&#x7684;&#x89E3;&#x6790;&#x7ED3;&#x679C;&#x662F;&#x51FD;&#x6570;&#x3001;&#x5B8F;&#x6216;&#x7279;&#x6B8A;&#x5F62;&#x5F0F;&#x7684;&#x8C03;&#x7528;&#xFF1B;&#x6240;&#x6709;&#x5176;&#x4ED6;&#x7C7B;&#x578B;&#x90FD;&#x89E3;&#x6790;&#x4E3A;&#x81EA;&#x8EAB;&#x3002;</p>
<blockquote>
<p>The coolest thing about this process is that it allows you to use Clojure to expand its own syntax. This process is made easier because Clojure is homoiconic: its text represents data structures, and those data structures represent abstract syntax trees, allowing you to more easily reason about how to construct syntax-expanding macros.</p>
</blockquote>
<p>&#x6700;&#x9177;&#x7684;&#x662F;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x5141;&#x8BB8;&#x4F60;&#x7528;Clojure&#x6269;&#x5C55;&#x81EA;&#x5DF1;&#x7684;&#x8BED;&#x6CD5;&#x3002;&#x56E0;&#x4E3A;Clojure&#x662F;&#x540C;&#x50CF;&#x6027;&#x8BED;&#x8A00;&#xFF0C;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x66F4;&#x5BB9;&#x6613;&#x4E86;&#xFF1A;&#x4EE3;&#x7801;&#x4EE3;&#x8868;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4EE3;&#x8868;&#x62BD;&#x8C61;&#x8BED;&#x6CD5;&#x6811;&#xFF0C;&#x4F7F;&#x4F60;&#x63A8;&#x65AD;&#x5982;&#x4F55;&#x6784;&#x5EFA;&#x8BED;&#x6CD5;&#x6269;&#x5C55;&#x5B8F;&#x53D8;&#x5F97;&#x66F4;&#x52A0;&#x5BB9;&#x6613;&#x3002;</p>
<blockquote>
<p>With all these new concepts in your brainacles, you&#x2019;re now ready to blow stuff up on purpose, just like I promised. The next chapter will teach you everything you need to know about writing macros. Hold on to your socks or they&#x2019;re liable to get knocked off!</p>
</blockquote>
<p>&#x8FD9;&#x4E9B;&#x6982;&#x5FF5;&#x4E3A;&#x4E0B;&#x7AE0;&#x505A;&#x597D;&#x4E86;&#x51C6;&#x5907;&#x3002;&#x4E0B;&#x7AE0;&#x4F1A;&#x8BB2;&#x8FF0;&#x5199;&#x5B8F;&#x9700;&#x8981;&#x7684;&#x6240;&#x6709;&#x77E5;&#x8BC6;&#xFF01;</p>
<blockquote>
<p>Exercises</p>
</blockquote>
<h2 id="&#x7EC3;&#x4E60;"><a href="#&#x7EC3;&#x4E60;" class="headerlink" title="&#x7EC3;&#x4E60;"></a>&#x7EC3;&#x4E60;</h2><blockquote>
<p>These exercises focus on reading and evaluation. Chapter 8 has exercises for writing macros.</p>
</blockquote>
<p>&#x8FD9;&#x4E9B;&#x7EC3;&#x4E60;&#x4E13;&#x6CE8;&#x4E8E;&#x8BFB;&#x5165;&#x548C;&#x6C42;&#x503C;&#x3002;&#x7B2C;8&#x7AE0;&#x6709;&#x5199;&#x5B8F;&#x7EC3;&#x4E60;&#x3002;</p>
<blockquote>
<ol>
<li>Use the <code>list</code> function, quoting, and <code>read-string</code> to create a list that, when evaluated, prints your first name and your favorite sci-fi movie.</li>
<li>Create an infix function that takes a list like <code>(1 + 3 * 4 - 5)</code> and transforms it into the lists that Clojure needs in order to correctly evaluate the expression using operator precedence rules.</li>
</ol>
</blockquote>
<ol>
<li>&#x4F7F;&#x7528;<code>list</code>&#x51FD;&#x6570;&#xFF0C;<code>quote</code> &#x548C; <code>read-string</code>&#x521B;&#x5EFA;&#x4E00;&#x4E2A;list,&#x8FD9;&#x4E2A;list&#x88AB;&#x6C42;&#x503C;&#x65F6;&#xFF0C;&#x6253;&#x5370;&#x4F60;&#x7684;&#x59D3;&#x548C;&#x4F60;&#x6700;&#x559C;&#x6B22;&#x7684;&#x79D1;&#x5E7B;&#x7535;&#x5F71;&#x3002;</li>
<li>&#x7F16;&#x5199;&#x4E00;&#x4E2A;infix&#x51FD;&#x6570;&#xFF0C;&#x63A5;&#x53D7;&#x5F62;&#x5982;<code>(1 + 3 * 4 - 5)</code>&#x7684;list&#xFF0C;&#x5E76;&#x8F6C;&#x6362;&#x6210;&#x4F18;&#x5148;&#x7EA7;&#x89C4;&#x5219;&#x6B63;&#x786E;&#x7684;Clojure&#x9700;&#x8981;&#x7684;list&#x3002;</li>
</ol>
<hr>
<p>&#x8BD1;&#x6587;&#x7ED3;&#x675F;&#x3002;</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Clojure/" rel="tag">#Clojure</a>
          
            <a href="/tags/Clojure-For-The-Branve-And-True/" rel="tag">#Clojure For The Branve And True</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/27/openclose-principle-use-case/" rel="next" title="OpenClose原则的几类使用场景">
                <i class="fa fa-chevron-left"></i> OpenClose原则的几类使用场景
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/20/braveclojure-writing-macros/" rel="prev" title="【译】写宏">
                【译】写宏 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://s.gravatar.com/avatar/954a8b1f4c32dbb5a11399ae5e236a5f?s=80"
               alt="胡军" />
          <p class="site-author-name" itemprop="name">胡军</p>
          <p class="site-description motion-element" itemprop="description">immutable values from past</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/morrxy" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Clojure求值模型概述"><span class="nav-number">1.</span> <span class="nav-text">Clojure求值模型概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读入程序"><span class="nav-number">2.</span> <span class="nav-text">读入程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读入"><span class="nav-number">2.1.</span> <span class="nav-text">读入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读入程序宏"><span class="nav-number">2.2.</span> <span class="nav-text">读入程序宏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#求值程序"><span class="nav-number">3.</span> <span class="nav-text">求值程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#这些东西求值结果是他们自身"><span class="nav-number">3.1.</span> <span class="nav-text">这些东西求值结果是他们自身</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号"><span class="nav-number">3.2.</span> <span class="nav-text">符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表"><span class="nav-number">3.3.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数调用"><span class="nav-number">3.3.1.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊形式"><span class="nav-number">3.3.2.</span> <span class="nav-text">特殊形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#宏"><span class="nav-number">3.3.3.</span> <span class="nav-text">宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语法抽象与-gt-宏"><span class="nav-number">3.3.4.</span> <span class="nav-text">语法抽象与 -> 宏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习"><span class="nav-number">5.</span> <span class="nav-text">练习</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">胡军</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'morrxy';
      var disqus_identifier = '2016/05/11/braveclojure-read-and-eval/';
      var disqus_title = '【译】Clojure炼金术:读取，求值，宏';
      var disqus_url = 'http://yoursite.com/2016/05/11/braveclojure-read-and-eval/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  

  


</body>
</html>
